# Comparing `tmp/aos_keys-1.5.2b3-py3-none-any.whl.zip` & `tmp/aos_keys-1.5.2b4-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,18 @@
-Zip file size: 17116 bytes, number of entries: 16
--rw-rw-r--  2.0 unx      117 b- defN 22-Jun-30 08:41 aos_keys/__init__.py
--rw-rw-r--  2.0 unx     6745 b- defN 23-May-23 08:41 aos_keys/actions.py
--rw-rw-r--  2.0 unx    10184 b- defN 23-Apr-04 10:59 aos_keys/certificate_manager.py
--rw-rw-r--  2.0 unx     3004 b- defN 23-Apr-04 11:14 aos_keys/cloud_api.py
--rw-rw-r--  2.0 unx     3789 b- defN 22-Sep-23 09:10 aos_keys/common.py
--rw-rw-r--  2.0 unx     4547 b- defN 23-Apr-04 10:59 aos_keys/crypto_container.py
--rw-rw-r--  2.0 unx     6210 b- defN 23-May-24 06:03 aos_keys/key_manager.py
--rw-rw-r--  2.0 unx     8397 b- defN 23-May-23 08:09 aos_keys/main.py
--rw-rw-r--  2.0 unx     1452 b- defN 22-Sep-23 09:10 aos_keys/files/1rootCA.crt
--rw-rw-r--  2.0 unx      113 b- defN 22-Jun-30 08:41 aos_keys/files/__init__.py
--rw-rw-r--  2.0 unx     2565 b- defN 23-May-24 06:04 aos_keys-1.5.2b3.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 23-May-24 06:04 aos_keys-1.5.2b3.dist-info/WHEEL
--rw-rw-r--  2.0 unx       48 b- defN 23-May-24 06:04 aos_keys-1.5.2b3.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx        9 b- defN 23-May-24 06:04 aos_keys-1.5.2b3.dist-info/top_level.txt
--rw-rw-r--  2.0 unx        1 b- defN 23-May-23 08:16 aos_keys-1.5.2b3.dist-info/zip-safe
-?rw-rw-r--  2.0 unx     1293 b- defN 23-May-24 06:04 aos_keys-1.5.2b3.dist-info/RECORD
-16 files, 48566 bytes uncompressed, 14986 bytes compressed:  69.1%
+Zip file size: 17459 bytes, number of entries: 16
+-rw-rw-rw-  2.0 fat      122 b- defN 22-Oct-12 12:55 aos_keys/__init__.py
+-rw-rw-rw-  2.0 fat     6887 b- defN 23-Jun-02 14:00 aos_keys/actions.py
+-rw-rw-rw-  2.0 fat    10782 b- defN 23-Jun-02 14:00 aos_keys/certificate_manager.py
+-rw-rw-rw-  2.0 fat     3092 b- defN 23-Mar-03 11:42 aos_keys/cloud_api.py
+-rw-rw-rw-  2.0 fat     4403 b- defN 23-Jun-02 14:00 aos_keys/common.py
+-rw-rw-rw-  2.0 fat     4674 b- defN 23-Apr-06 10:09 aos_keys/crypto_container.py
+-rw-rw-rw-  2.0 fat     6336 b- defN 23-May-24 10:21 aos_keys/key_manager.py
+-rw-rw-rw-  2.0 fat     8715 b- defN 23-Jun-02 14:00 aos_keys/main.py
+-rw-rw-rw-  2.0 fat     1476 b- defN 22-Oct-12 12:55 aos_keys/files/1rootCA.crt
+-rw-rw-rw-  2.0 fat      118 b- defN 22-Oct-12 12:55 aos_keys/files/__init__.py
+-rw-rw-rw-  2.0 fat     2585 b- defN 23-Jun-02 14:01 aos_keys-1.5.2b4.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 23-Jun-02 14:01 aos_keys-1.5.2b4.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat       49 b- defN 23-Jun-02 14:01 aos_keys-1.5.2b4.dist-info/entry_points.txt
+-rw-rw-rw-  2.0 fat        9 b- defN 23-Jun-02 14:01 aos_keys-1.5.2b4.dist-info/top_level.txt
+-rw-rw-rw-  2.0 fat        2 b- defN 22-Feb-10 13:27 aos_keys-1.5.2b4.dist-info/zip-safe
+?rw-rw-r--  2.0 fat     1293 b- defN 23-Jun-02 14:01 aos_keys-1.5.2b4.dist-info/RECORD
+16 files, 50635 bytes uncompressed, 15329 bytes compressed:  69.7%
```

## zipnote {}

```diff
@@ -24,26 +24,26 @@
 
 Filename: aos_keys/files/1rootCA.crt
 Comment: 
 
 Filename: aos_keys/files/__init__.py
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/METADATA
+Filename: aos_keys-1.5.2b4.dist-info/METADATA
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/WHEEL
+Filename: aos_keys-1.5.2b4.dist-info/WHEEL
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/entry_points.txt
+Filename: aos_keys-1.5.2b4.dist-info/entry_points.txt
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/top_level.txt
+Filename: aos_keys-1.5.2b4.dist-info/top_level.txt
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/zip-safe
+Filename: aos_keys-1.5.2b4.dist-info/zip-safe
 Comment: 
 
-Filename: aos_keys-1.5.2b3.dist-info/RECORD
+Filename: aos_keys-1.5.2b4.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## aos_keys/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""Main aos-keys module."""
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""Main aos-keys module."""
```

## aos_keys/actions.py

```diff
@@ -1,196 +1,196 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""aos-keys actions."""
-
-import platform
-from pathlib import Path
-
-from requests import HTTPError
-from rich.table import Table
-
-from aos_keys.certificate_manager import (
-    install_root_certificate_macos,
-    install_root_certificate_linux,
-    install_root_certificate_windows,
-    install_user_certificate_windows,
-    install_user_certificate_linux,
-    install_user_certificate_macos,
-)
-from aos_keys.cloud_api import receive_certificate_by_token, get_user_info_by_cert
-from aos_keys.common import (
-    DEFAULT_FLEET_FILE_NAME,
-    DEFAULT_OEM_FILE_NAME,
-    DEFAULT_SP_FILE_NAME,
-    DEFAULT_ADMIN_FILE_NAME,
-    UserType,
-)
-from aos_keys.common import console, AosKeysError
-from aos_keys.key_manager import generate_pair, pem_to_pkcs12_bytes, pkcs12_to_pem_bytes, print_cert_info
-
-
-def install_user_certificate(path_to_certificate):
-    """Install Cloud root certificate system-wide.
-
-    Args:
-        path_to_certificate: Path to user certificate to install.
-
-    Raises:
-        AosKeysError: If something fails.
-    """
-    if not Path(path_to_certificate).exists():
-        raise AosKeysError(f'File {path_to_certificate} not found!')
-
-    if platform.system() == 'Windows':
-        install_user_certificate_windows(path_to_certificate)
-    elif platform.system() == 'Linux':
-        install_user_certificate_linux(path_to_certificate)
-    elif platform.system() == 'Darwin':
-        install_user_certificate_macos(path_to_certificate)
-    else:
-        raise AosKeysError('Unsupported platform')
-
-
-def install_root_ca():
-    """Install Cloud root certificate system-wide.
-
-    Raises:
-        AosKeysError: If something fails.
-    """
-    if platform.system() == 'Windows':
-        install_root_certificate_windows()
-    elif platform.system() == 'Linux':
-        install_root_certificate_linux()
-    elif platform.system() == 'Darwin':
-        install_root_certificate_macos()
-    else:
-        raise AosKeysError('Unsupported platform')
-
-
-def new_token_user(domain: str, output_directory: str, auth_token: str, user_type: UserType, create_ecc_key):
-    """Create a new user key/certificate and register it on the cloud.
-
-    Args:
-        domain: Domain where to register user.
-        output_directory: Directory to save user key/certificate.
-        auth_token: Authenticity token for cloud.
-        user_type: Type of user (SP or OEM).
-        create_ecc_key: This is a second param.
-
-    Raises:
-        AosKeysError: If user hasn't the access to the cloud or his role is not OEM.
-    """
-    Path(output_directory).mkdir(parents=True, exist_ok=True)
-    names = {
-        UserType.SP.value: {
-            'path': Path(output_directory) / DEFAULT_SP_FILE_NAME,
-            'friendly_name': 'Aos SP client certificate',
-        },
-        UserType.OEM.value: {
-            'path': Path(output_directory) / DEFAULT_OEM_FILE_NAME,
-            'friendly_name': 'Aos OEM client certificate',
-        },
-        UserType.FLEET.value: {
-            'path': Path(output_directory) / DEFAULT_FLEET_FILE_NAME,
-            'friendly_name': 'Aos Fleet Owner client certificate',
-        },
-        UserType.ADMIN.value: {
-            'path': Path(output_directory) / DEFAULT_ADMIN_FILE_NAME,
-            'friendly_name': 'Aos ADMIN client certificate',
-        },
-    }
-    config = names[user_type.value]
-
-    if config['path'].exists():
-        raise AosKeysError(f'File {config["path"]} exists. Cannot proceed!')
-
-    private_key_bytes, csr = generate_pair(create_ecc_key)
-    user_certificate = receive_certificate_by_token(domain, token=auth_token, csr=csr.decode())
-    pkcs12_bytes = pem_to_pkcs12_bytes(
-        private_key_bytes,
-        user_certificate.encode(encoding='UTF-8'),
-        config['friendly_name'],
-    )
-
-    with open(config['path'], 'wb') as save_file:
-        save_file.write(pkcs12_bytes)
-
-    console.print(f'File {config["path"]} created', style='green')
-    console.print('Done!', style='green')
-
-
-def convert_pkcs12_file_to_pem(pkcs12_path: str, output_dir: str):
-    """Convert pkcs12 file to pem key and certificate.
-
-    Args:
-        pkcs12_path: Full path to user certificate in pkcs12 format.
-        output_dir: Directory to store pem files.
-
-    Raises:
-        AosKeysError: If can't create new files.
-
-    """
-    Path(output_dir).mkdir(parents=True, exist_ok=True)
-    cert_file_name = Path(output_dir) / 'user-certificate.pem'
-    key_file_name = Path(output_dir) / 'user-key.pem'
-
-    if not Path(pkcs12_path).exists():
-        raise AosKeysError(f'File {pkcs12_path} not found. Cannot proceed!')
-
-    for file_name in (cert_file_name, key_file_name):
-        if file_name.exists():
-            raise AosKeysError(f'Destination file {file_name} exists. Cannot proceed!')
-
-    with open(pkcs12_path, 'rb') as pkcs12_file:
-        key_bytes, cert_bytes = pkcs12_to_pem_bytes(pkcs12_file.read())
-
-    with open(cert_file_name, 'wb') as cert:
-        cert.write(cert_bytes)
-        console.print(f'File created: {cert_file_name}!', style='green')
-
-    with open(key_file_name, 'wb') as key:
-        key.write(key_bytes)
-        console.print(f'File created: {key_file_name}!', style='green')
-
-    console.print('Done!', style='green')
-
-
-def print_user_info(pkcs12_path: str):
-    """Print info about user certificate and available permissions on the cloud.
-
-    Args:
-        pkcs12_path: Full path to user certificate in pkcs12 format.
-
-    Raises:
-        AosKeysError: If received error during communication with Cloud.
-    """
-    print_cert_info(pkcs12_path)
-    try:
-        user_info = get_user_info_by_cert(pkcs12_path)
-    except HTTPError as net_err:
-        raise AosKeysError('Error receiving user info') from net_err
-
-    user_role = user_info.get('role', '')
-    print_info = {
-        'User name: ': user_info.get('username'),
-        'email: ': user_info.get('email'),
-        'role: ': user_role,
-    }
-
-    if user_role in ('oem', 'fleet owner'):
-        print_info['OEM Title:'] = user_info.get('oem').get('title')
-        print_info['Fleets:'] = '\n'.join(fleet['title'] for fleet in user_info.get('fleets', []))
-    elif user_role == 'service provider':
-        print_info['SP Title:'] = user_info.get('service_provider').get('title')
-
-    print_info['Permission groups: '] = '\n'.join(user_info.get('permission_groups', []))
-    print_info['Standalone permissions: '] = '\n'.join(user_info.get('permissions', []))
-
-    table = Table(padding=0, title='Cloud user info', show_header=False)
-    table.add_column('', no_wrap=True, justify='left', style='')
-    table.add_column('')
-    for head in print_info:
-        table.add_row(head, str(print_info[head]))
-
-    console.print(table)
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""aos-keys actions."""
+
+import platform
+from pathlib import Path
+
+from requests import HTTPError
+from rich.table import Table
+
+from aos_keys.certificate_manager import (
+    install_root_certificate_macos,
+    install_root_certificate_linux,
+    install_root_certificate_windows,
+    install_user_certificate_windows,
+    install_user_certificate_linux,
+    install_user_certificate_macos,
+)
+from aos_keys.cloud_api import receive_certificate_by_token, get_user_info_by_cert
+from aos_keys.common import (
+    DEFAULT_FLEET_FILE_NAME,
+    DEFAULT_OEM_FILE_NAME,
+    DEFAULT_SP_FILE_NAME,
+    DEFAULT_ADMIN_FILE_NAME,
+    UserType,
+)
+from aos_keys.common import AosKeysError, print_success, print_message
+from aos_keys.key_manager import generate_pair, pem_to_pkcs12_bytes, pkcs12_to_pem_bytes, print_cert_info
+
+
+def install_user_certificate(path_to_certificate):
+    """Install Cloud root certificate system-wide.
+
+    Args:
+        path_to_certificate: Path to user certificate to install.
+
+    Raises:
+        AosKeysError: If something fails.
+    """
+    if not Path(path_to_certificate).exists():
+        raise AosKeysError(f'File {path_to_certificate} not found!')
+
+    if platform.system() == 'Windows':
+        install_user_certificate_windows(path_to_certificate)
+    elif platform.system() == 'Linux':
+        install_user_certificate_linux(path_to_certificate)
+    elif platform.system() == 'Darwin':
+        install_user_certificate_macos(path_to_certificate)
+    else:
+        raise AosKeysError('Unsupported platform')
+
+
+def install_root_ca():
+    """Install Cloud root certificate system-wide.
+
+    Raises:
+        AosKeysError: If something fails.
+    """
+    if platform.system() == 'Windows':
+        install_root_certificate_windows()
+    elif platform.system() == 'Linux':
+        install_root_certificate_linux()
+    elif platform.system() == 'Darwin':
+        install_root_certificate_macos()
+    else:
+        raise AosKeysError('Unsupported platform')
+
+
+def new_token_user(domain: str, output_directory: str, auth_token: str, user_type: UserType, create_ecc_key):
+    """Create a new user key/certificate and register it on the cloud.
+
+    Args:
+        domain: Domain where to register user.
+        output_directory: Directory to save user key/certificate.
+        auth_token: Authenticity token for cloud.
+        user_type: Type of user (SP or OEM).
+        create_ecc_key: This is a second param.
+
+    Raises:
+        AosKeysError: If user hasn't the access to the cloud or his role is not OEM.
+    """
+    Path(output_directory).mkdir(parents=True, exist_ok=True)
+    names = {
+        UserType.SP.value: {
+            'path': Path(output_directory) / DEFAULT_SP_FILE_NAME,
+            'friendly_name': 'Aos SP client certificate',
+        },
+        UserType.OEM.value: {
+            'path': Path(output_directory) / DEFAULT_OEM_FILE_NAME,
+            'friendly_name': 'Aos OEM client certificate',
+        },
+        UserType.FLEET.value: {
+            'path': Path(output_directory) / DEFAULT_FLEET_FILE_NAME,
+            'friendly_name': 'Aos Fleet Owner client certificate',
+        },
+        UserType.ADMIN.value: {
+            'path': Path(output_directory) / DEFAULT_ADMIN_FILE_NAME,
+            'friendly_name': 'Aos ADMIN client certificate',
+        },
+    }
+    config = names[user_type.value]
+
+    if config['path'].exists():
+        raise AosKeysError(f'File {config["path"]} exists. Cannot proceed!')
+
+    private_key_bytes, csr = generate_pair(create_ecc_key)
+    user_certificate = receive_certificate_by_token(domain, token=auth_token, csr=csr.decode())
+    pkcs12_bytes = pem_to_pkcs12_bytes(
+        private_key_bytes,
+        user_certificate.encode(encoding='UTF-8'),
+        config['friendly_name'],
+    )
+
+    with open(config['path'], 'wb') as save_file:
+        save_file.write(pkcs12_bytes)
+
+    print_success(f'File {config["path"]} created')
+    print_success('Done!')
+
+
+def convert_pkcs12_file_to_pem(pkcs12_path: str, output_dir: str):
+    """Convert pkcs12 file to pem key and certificate.
+
+    Args:
+        pkcs12_path: Full path to user certificate in pkcs12 format.
+        output_dir: Directory to store pem files.
+
+    Raises:
+        AosKeysError: If can't create new files.
+
+    """
+    Path(output_dir).mkdir(parents=True, exist_ok=True)
+    cert_file_name = Path(output_dir) / 'user-certificate.pem'
+    key_file_name = Path(output_dir) / 'user-key.pem'
+
+    if not Path(pkcs12_path).exists():
+        raise AosKeysError(f'File {pkcs12_path} not found. Cannot proceed!')
+
+    for file_name in (cert_file_name, key_file_name):
+        if file_name.exists():
+            raise AosKeysError(f'Destination file {file_name} exists. Cannot proceed!')
+
+    with open(pkcs12_path, 'rb') as pkcs12_file:
+        key_bytes, cert_bytes = pkcs12_to_pem_bytes(pkcs12_file.read())
+
+    with open(cert_file_name, 'wb') as cert:
+        cert.write(cert_bytes)
+        print_success(f'File created: {cert_file_name}!')
+
+    with open(key_file_name, 'wb') as key:
+        key.write(key_bytes)
+        print_success(f'File created: {key_file_name}!')
+
+    print_success('Done!')
+
+
+def print_user_info(pkcs12_path: str):
+    """Print info about user certificate and available permissions on the cloud.
+
+    Args:
+        pkcs12_path: Full path to user certificate in pkcs12 format.
+
+    Raises:
+        AosKeysError: If received error during communication with Cloud.
+    """
+    print_cert_info(pkcs12_path)
+    try:
+        user_info = get_user_info_by_cert(pkcs12_path)
+    except HTTPError as net_err:
+        raise AosKeysError('Error receiving user info') from net_err
+
+    user_role = user_info.get('role', '')
+    print_info = {
+        'User name: ': user_info.get('username'),
+        'email: ': user_info.get('email'),
+        'role: ': user_role,
+    }
+
+    if user_role in ('oem', 'fleet owner'):
+        print_info['OEM Title:'] = user_info.get('oem').get('title')
+        print_info['Fleets:'] = '\n'.join(fleet['title'] for fleet in user_info.get('fleets', []))
+    elif user_role == 'service provider':
+        print_info['SP Title:'] = user_info.get('service_provider').get('title')
+
+    print_info['Permission groups: '] = '\n'.join(user_info.get('permission_groups', []))
+    print_info['Standalone permissions: '] = '\n'.join(user_info.get('permissions', []))
+
+    table = Table(padding=0, title='Cloud user info', show_header=False)
+    table.add_column('', no_wrap=True, justify='left', style='')
+    table.add_column('')
+    for head in print_info:
+        table.add_row(head, str(print_info[head]))
+
+    print_message(table)
```

## aos_keys/certificate_manager.py

```diff
@@ -1,276 +1,289 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""Install root and client certificates on different OSes."""
-import glob
-import os
-import platform
-import subprocess
-import tempfile
-from typing import List
-
-from cryptography.hazmat.primitives import hashes
-from cryptography.hazmat.primitives.serialization import PrivateFormat, pkcs12, BestAvailableEncryption
-from pathlib import Path
-
-from aos_keys.common import ca_certificate, AosKeysError, console
-
-
-def _execute_command(command):
-
-    try:
-        completed_process = subprocess.run(command, capture_output=False, env=os.environ.copy())
-    except KeyboardInterrupt:
-        raise AosKeysError('Operation interrupted by user')
-    if completed_process.returncode == 0:
-        return
-
-    error = completed_process.stderr
-    if not error and completed_process.stdout:
-        error = completed_process.stdout
-        if error:
-            error = error.decode("utf8")
-    print(completed_process.stderr)
-    raise AosKeysError(f'Failed to install certificate:\n {error}')
-
-
-def install_root_certificate_macos():
-    """Install root certificate on current user's Trusted Root CA."""
-    with ca_certificate() as server_certificate_path:
-        print('We are going to add Aos Root certificate as trusted certificate.')
-        print('The OS will ask your password to proceed with operation.')
-        command = [
-            'security',
-            'add-trusted-cert',
-            '-r',
-            'trustRoot',
-            str(server_certificate_path),
-        ]
-        _execute_command(command)
-
-
-def install_root_certificate_windows():
-    """Install root certificate on current user's Trusted Root CA."""
-    with ca_certificate() as server_certificate_path:
-        command = ['certutil', '-addstore', '-f', '-user', 'Root', server_certificate_path]
-        _execute_command(command)
-
-
-def install_root_certificate_linux():
-    """Install root certificate on linux host."""
-
-    firefox_profiles = find_firefox_profile_locations()
-
-    command = ['dpkg', '-s', 'ca-certificates']
-    completed_process = subprocess.run(command, capture_output=True)
-    if completed_process.returncode > 0:
-        raise AosKeysError(
-            'Failed to install certificate. "update-ca-certificates" package is missing',
-            'Install update-ca-certificates with command: sudo apt install ca-certificates',
-        )
-
-    command = ['dpkg', '-s', 'libnss3-tools']
-    completed_process = subprocess.run(command, capture_output=True)
-    if completed_process.returncode > 0:
-        raise AosKeysError(
-            'Failed to install certificate. "libnss3-tools" package is missing',
-            'Install libnss3-tools with command: sudo apt install libnss3-tools',
-        )
-
-    # Create empty user's certificate DB if absent
-    nssdb_dir = str(Path.home() / '.pki' / 'nssdb')
-    if not os.path.exists(nssdb_dir):
-        os.makedirs(nssdb_dir, exist_ok=True)
-        command = ['certutil', '-d', nssdb_dir, '-N', '--empty-password']
-        completed_process = subprocess.run(command, capture_output=True)
-        if completed_process.returncode > 0:
-            raise AosKeysError("Failed to create empty user's certificate DB")
-        console.print('Empty users certificate DB has been successfully created', style='green')
-
-    with ca_certificate() as server_certificate_path:
-        (Path.home() / '.aos' / 'scripts').mkdir(parents=True, exist_ok=True)
-
-        script_filename = f'{str(Path.home())}/.aos/scripts/install_aos_root_ca.sh'
-        with open(script_filename, 'wt') as file_handle:
-            file_handle.write('mkdir -p /usr/local/share/ca-certificates\n')
-            file_handle.write(f'cp {server_certificate_path} /usr/local/share/ca-certificates/AosRootCA.crt\n')
-            file_handle.write(f'update-ca-certificates\n')
-        command = ['chmod', '+x', script_filename]
-        _execute_command(command)
-
-        console.print('To install system root certificate execute next command:', style='green')
-        print('sudo ~/.aos/scripts/install_aos_root_ca.sh\n')
-
-        with tempfile.NamedTemporaryFile() as password_file:
-            # empty password file prevents asking password from stdin
-            command = [
-                'certutil',
-                '-d', f'sql:{str(Path.home())}/.pki/nssdb',
-                '-A', '-t', 'C',
-                '-n', 'Aos root certificate',
-                '-i', server_certificate_path,
-                '-f', password_file.name,
-            ]
-            _execute_command(command)
-
-            for firefox_profile in firefox_profiles:
-                command = [
-                    'certutil',
-                    '-d', f'sql:{firefox_profile}',
-                    '-A', '-t', 'C',
-                    '-n', 'Aos root certificate',
-                    '-i', server_certificate_path,
-                    '-f', password_file.name,
-                ]
-                _execute_command(command)
-
-
-def add_password_to_pkcs12(filename_in: str, filename_out: str, password: bytes, friendly_name: bytes or None):
-    with open(filename_in, 'rb') as file_handle:
-        pkcs12_bytes = file_handle.read()
-    key_certificates = pkcs12.load_pkcs12(pkcs12_bytes, None)
-
-    # This code should be used after PR release https://github.com/pyca/cryptography/pull/7560/
-    encryption = (
-        PrivateFormat.PKCS12.encryption_builder().
-        kdf_rounds(50000).
-        key_cert_algorithm(pkcs12.PBES.PBESv1SHA1And3KeyTripleDESCBC).
-        hmac_hash(hashes.SHA1()).build(password)
-    )
-
-    protected_pkcs12_bytes = pkcs12.serialize_key_and_certificates(
-        friendly_name,
-        key_certificates.key,
-        key_certificates.cert.certificate,
-        [cert.certificate for cert in key_certificates.additional_certs],
-        # BestAvailableEncryption(password),
-        encryption,  # See comment above
-    )
-    with open(filename_out, 'wb') as file_handle:
-        file_handle.write(protected_pkcs12_bytes)
-
-
-def find_firefox_profile_locations() -> List[str]:
-    home_dir = Path.home()
-
-    results = []
-
-    # Based on http://kb.mozillazine.org/Profile_folder_-_Firefox
-
-    if platform.system() == "Linux":
-        # Linux:
-        #  ~/.mozilla/firefox/profile
-        #  ~/snap/firefox/profile
-        for root, _, files in os.walk(os.path.join(home_dir, '.mozilla', 'firefox')):
-            if 'cert9.db' in files:
-                results.append(root)
-
-        for browser in ['firefox', 'opera', 'chromium', 'chrome']:
-            for root, _, files in os.walk(os.path.join(home_dir, 'snap', browser)):
-                if 'cert9.db' in files:
-                    results.append(root)
-
-    if platform.system() == 'Darwin':
-        # macOS:
-        #  ~/Library/Application Support/Firefox/Profiles/<profile folder>
-        #  ~/Library/Mozilla/Firefox/Profiles/<profile folder>
-        for root, _, files in os.walk(os.path.join(home_dir, 'Library', 'Application Support', 'Firefox', 'Profiles')):
-            if 'cert9.db' in files:
-                results.append(root)
-
-        for root, _, files in os.walk(os.path.join(home_dir, 'Library', 'Mozilla', 'Firefox', 'Profiles')):
-            if 'cert9.db' in files:
-                results.append(root)
-
-    if platform.system() == 'Windows':
-        # Windows: %APPDATA%\Mozilla\Firefox\Profiles
-        home_dir = os.environ.get('APPDATA', '')
-        if home_dir:
-            for root, _, files in os.walk(os.path.join(home_dir, 'Mozilla', 'Firefox', 'Profiles')):
-                if 'cert9.db' in files:
-                    results.append(root)
-
-    return results
-
-
-def install_user_certificate_windows(certificate_path: Path):
-    """Install client certificate to the Windows Personal store.
-
-    Args:
-        certificate_path: path to certificate which will be installed.
-    """
-    print('We are going to import your private key and certificate to your personal store.')
-    password_protected_filename = str(certificate_path) + '.pswd'
-    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
-    command = [
-        'certutil',
-        '-importpfx',
-        '-f',
-        '-user',
-        '-p',
-        '1234',
-        password_protected_filename,
-    ]
-    try:
-        _execute_command(command)
-    finally:
-        os.unlink(password_protected_filename)
-
-
-def install_user_certificate_linux(certificate_path: Path):
-    """Install client certificate to the Windows Personal store.
-
-    Args:
-        certificate_path: path to certificate which will be installed.
-    """
-    print('We are going to import your private key and certificate to browsers databases.')
-    password_protected_filename = str(certificate_path) + '.pswd'
-    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
-
-    firefox_profiles = find_firefox_profile_locations()
-    all_profiles = [f'sql:{str(Path.home())}/.pki/nssdb']
-    all_profiles.extend(firefox_profiles)
-
-    with tempfile.NamedTemporaryFile() as password_file:
-        password_file.write(b'1234')
-        password_file.flush()
-
-        try:
-            for profile_item in all_profiles:
-                command = [
-                    'pk12util',
-                    '-d',
-                    profile_item,
-                    '-i',
-                    password_protected_filename,
-                    '-w',
-                    password_file.name,
-                ]
-                _execute_command(command)
-        finally:
-            os.unlink(password_protected_filename)
-
-
-def install_user_certificate_macos(certificate_path: Path):
-    """Install client certificate to the Windows Personal store.
-
-    Args:
-        certificate_path: path to certificate which will be installed.
-    """
-    password_protected_filename = str(certificate_path) + '.pswd'
-    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
-
-    command = [
-        'security',
-        'import',
-        password_protected_filename,
-        '-f',
-        'pkcs12',
-        '-P',
-        '1234',
-    ]
-    try:
-        _execute_command(command)
-    finally:
-        os.unlink(password_protected_filename)
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""Install root and client certificates on different OSes."""
+import os
+import platform
+import subprocess
+import tempfile
+from pathlib import Path
+from typing import List
+
+from cryptography.hazmat.primitives import hashes
+from cryptography.hazmat.primitives.serialization import PrivateFormat, pkcs12
+
+from aos_keys.common import ca_certificate, AosKeysError, print_error, print_message, print_success
+
+
+def _execute_command(command):
+    try:
+        completed_process = subprocess.run(command, capture_output=False, env=os.environ.copy())
+    except KeyboardInterrupt:
+        raise AosKeysError('Operation interrupted by user')
+    if completed_process.returncode == 0:
+        return
+
+    error = completed_process.stderr
+    if not error and completed_process.stdout:
+        error = completed_process.stdout
+        if error:
+            error = error.decode("utf8")
+    print_error(completed_process.stderr)
+    raise AosKeysError(f'Failed to install certificate:\n {error}')
+
+def _check_linux_has_pk12util():
+    """Check if libnss3-tools present on the Linux host.
+
+    Raises:
+        AosKeysError: If libnss3-tools is not installed.
+    """
+    if subprocess.run(['dpkg', '-s', 'libnss3-tools'], capture_output=True).returncode == 0:
+        return
+
+    raise AosKeysError(
+        'Failed to install certificate. "libnss3-tools" package is missing',
+        'Install libnss3-tools with command: sudo apt install libnss3-tools',
+    )
+
+def _check_linux_has_ca_certificates():
+    """Check if ca-certificates present on the Linux host.
+
+    Raises:
+        AosKeysError: If ca-certificates is not installed.
+    """
+    if subprocess.run(['dpkg', '-s', 'ca-certificates'], capture_output=True).returncode == 0:
+        return
+
+    raise AosKeysError(
+        'Failed to install certificate. "update-ca-certificates" package is missing',
+            'Install update-ca-certificates with command: sudo apt install ca-certificates',
+    )
+
+
+def install_root_certificate_macos():
+    """Install root certificate on current user's Trusted Root CA."""
+    with ca_certificate() as server_certificate_path:
+        print_message('We are going to add Aos Root certificate as trusted certificate.')
+        print_message('The OS will ask your password to proceed with operation.')
+        command = [
+            'security',
+            'add-trusted-cert',
+            '-r',
+            'trustRoot',
+            str(server_certificate_path),
+        ]
+        _execute_command(command)
+
+
+def install_root_certificate_windows():
+    """Install root certificate on current user's Trusted Root CA."""
+    with ca_certificate() as server_certificate_path:
+        command = ['certutil', '-addstore', '-f', '-user', 'Root', server_certificate_path]
+        _execute_command(command)
+
+
+def install_root_certificate_linux():
+    """Install root certificate on linux host."""
+
+    _check_linux_has_ca_certificates()
+    _check_linux_has_pk12util()
+
+    firefox_profiles = find_firefox_profile_locations()
+
+    # Create empty user's certificate DB if absent
+    nssdb_dir = str(Path.home() / '.pki' / 'nssdb')
+    if not os.path.exists(nssdb_dir):
+        os.makedirs(nssdb_dir, exist_ok=True)
+        command = ['certutil', '-d', nssdb_dir, '-N', '--empty-password']
+        completed_process = subprocess.run(command, capture_output=True)
+        if completed_process.returncode > 0:
+            raise AosKeysError("Failed to create empty user's certificate DB")
+        print_success('Empty users certificate DB has been successfully created')
+
+    with ca_certificate() as server_certificate_path:
+        (Path.home() / '.aos' / 'scripts').mkdir(parents=True, exist_ok=True)
+
+        script_filename = f'{str(Path.home())}/.aos/scripts/install_aos_root_ca.sh'
+        with open(script_filename, 'wt') as file_handle:
+            file_handle.write('mkdir -p /usr/local/share/ca-certificates\n')
+            file_handle.write(f'cp {server_certificate_path} /usr/local/share/ca-certificates/AosRootCA.crt\n')
+            file_handle.write(f'update-ca-certificates\n')
+        command = ['chmod', '+x', script_filename]
+        _execute_command(command)
+
+        print_success('To install system root certificate execute next command:')
+        print_message('sudo ~/.aos/scripts/install_aos_root_ca.sh\n')
+
+        with tempfile.NamedTemporaryFile() as password_file:
+            # empty password file prevents asking password from stdin
+            command = [
+                'certutil',
+                '-d', f'sql:{str(Path.home())}/.pki/nssdb',
+                '-A', '-t', 'C',
+                '-n', 'Aos root certificate',
+                '-i', server_certificate_path,
+                '-f', password_file.name,
+            ]
+            _execute_command(command)
+
+            for firefox_profile in firefox_profiles:
+                command = [
+                    'certutil',
+                    '-d', f'sql:{firefox_profile}',
+                    '-A', '-t', 'C',
+                    '-n', 'Aos root certificate',
+                    '-i', server_certificate_path,
+                    '-f', password_file.name,
+                ]
+                _execute_command(command)
+
+
+def add_password_to_pkcs12(filename_in: str, filename_out: str, password: bytes, friendly_name: bytes or None):
+    with open(filename_in, 'rb') as file_handle:
+        pkcs12_bytes = file_handle.read()
+    key_certificates = pkcs12.load_pkcs12(pkcs12_bytes, None)
+
+    # This code should be used after PR release https://github.com/pyca/cryptography/pull/7560/
+    encryption = (
+        PrivateFormat.PKCS12.encryption_builder().
+        kdf_rounds(50000).
+        key_cert_algorithm(pkcs12.PBES.PBESv1SHA1And3KeyTripleDESCBC).
+        hmac_hash(hashes.SHA1()).build(password)
+    )
+
+    protected_pkcs12_bytes = pkcs12.serialize_key_and_certificates(
+        friendly_name,
+        key_certificates.key,
+        key_certificates.cert.certificate,
+        [cert.certificate for cert in key_certificates.additional_certs],
+        # BestAvailableEncryption(password),
+        encryption,  # See comment above
+    )
+    with open(filename_out, 'wb') as file_handle:
+        file_handle.write(protected_pkcs12_bytes)
+
+
+def find_firefox_profile_locations() -> List[str]:
+    home_dir = Path.home()
+
+    results = []
+
+    # Based on http://kb.mozillazine.org/Profile_folder_-_Firefox
+
+    if platform.system() == "Linux":
+        # Linux:
+        #  ~/.mozilla/firefox/profile
+        #  ~/snap/firefox/profile
+        for root, _, files in os.walk(os.path.join(home_dir, '.mozilla', 'firefox')):
+            if 'cert9.db' in files:
+                results.append(root)
+
+        for browser in ['firefox', 'opera', 'chromium', 'chrome']:
+            for root, _, files in os.walk(os.path.join(home_dir, 'snap', browser)):
+                if 'cert9.db' in files:
+                    results.append(root)
+
+    if platform.system() == 'Darwin':
+        # macOS:
+        #  ~/Library/Application Support/Firefox/Profiles/<profile folder>
+        #  ~/Library/Mozilla/Firefox/Profiles/<profile folder>
+        for root, _, files in os.walk(os.path.join(home_dir, 'Library', 'Application Support', 'Firefox', 'Profiles')):
+            if 'cert9.db' in files:
+                results.append(root)
+
+        for root, _, files in os.walk(os.path.join(home_dir, 'Library', 'Mozilla', 'Firefox', 'Profiles')):
+            if 'cert9.db' in files:
+                results.append(root)
+
+    if platform.system() == 'Windows':
+        # Windows: %APPDATA%\Mozilla\Firefox\Profiles
+        home_dir = os.environ.get('APPDATA', '')
+        if home_dir:
+            for root, _, files in os.walk(os.path.join(home_dir, 'Mozilla', 'Firefox', 'Profiles')):
+                if 'cert9.db' in files:
+                    results.append(root)
+
+    return results
+
+
+def install_user_certificate_windows(certificate_path: Path):
+    """Install client certificate to the Windows Personal store.
+
+    Args:
+        certificate_path: path to certificate which will be installed.
+    """
+    print_message('We are going to import your private key and certificate to your personal store.')
+    password_protected_filename = str(certificate_path) + '.pswd'
+    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
+    command = [
+        'certutil',
+        '-importpfx',
+        '-f',
+        '-user',
+        '-p',
+        '1234',
+        password_protected_filename,
+    ]
+    try:
+        _execute_command(command)
+    finally:
+        os.unlink(password_protected_filename)
+
+
+def install_user_certificate_linux(certificate_path: Path):
+    """Install client certificate to the Windows Personal store.
+
+    Args:
+        certificate_path: path to certificate which will be installed.
+    """
+    print_message('We are going to import your private key and certificate to browsers databases.')
+    password_protected_filename = str(certificate_path) + '.pswd'
+    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
+
+    firefox_profiles = find_firefox_profile_locations()
+    all_profiles = [f'sql:{str(Path.home())}/.pki/nssdb']
+    all_profiles.extend(firefox_profiles)
+
+    with tempfile.NamedTemporaryFile() as password_file:
+        password_file.write(b'1234')
+        password_file.flush()
+
+        try:
+            for profile_item in all_profiles:
+                command = [
+                    'pk12util',
+                    '-d',
+                    profile_item,
+                    '-i',
+                    password_protected_filename,
+                    '-w',
+                    password_file.name,
+                ]
+                _execute_command(command)
+        finally:
+            os.unlink(password_protected_filename)
+
+
+def install_user_certificate_macos(certificate_path: Path):
+    """Install client certificate to the Windows Personal store.
+
+    Args:
+        certificate_path: path to certificate which will be installed.
+    """
+    password_protected_filename = str(certificate_path) + '.pswd'
+    add_password_to_pkcs12(str(certificate_path), password_protected_filename, b'1234', None)
+
+    command = [
+        'security',
+        'import',
+        password_protected_filename,
+        '-f',
+        'pkcs12',
+        '-P',
+        '1234',
+    ]
+    try:
+        _execute_command(command)
+    finally:
+        os.unlink(password_protected_filename)
```

## aos_keys/cloud_api.py

 * *Ordering differences only*

```diff
@@ -1,88 +1,88 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""aos-keys cloud API implementations."""
-from urllib.parse import urljoin
-
-from requests import post
-from requests.exceptions import SSLError
-
-from aos_keys.common import ca_certificate, AosKeysError
-from aos_keys.crypto_container import AosCryptoContainer
-from aos_keys.key_manager import extract_cloud_domain_from_cert
-
-
-_ME_CERT_ENDPOINT = '/api/v3/users/me/'
-_UPLOAD_USER_CERTIFICATE = '/api/v3/user-certificates/'
-
-
-INVALID_TOKEN_ERROR = AosKeysError(
-    'FORBIDDEN status was received from the AosEdge Cloud!',
-    help_text='Access token is wrong or already used',
-)
-
-
-def get_user_info_by_cert(pkcs12_path: str):
-    """Get user info from the Cloud by user certificate.
-
-    Args:
-        pkcs12_path: Full path to user certificate in pkcs12 format.
-
-    Returns:
-        Json response from cloud
-    """
-    domain = extract_cloud_domain_from_cert(pkcs12_path)
-    with ca_certificate() as server_certificate_path:
-        with AosCryptoContainer(pkcs12_path).create_requests_session() as session:
-            response = session.get(
-                urljoin(f'https://{domain}:10000', _ME_CERT_ENDPOINT),
-                verify=server_certificate_path,
-            )
-            response.raise_for_status()
-            return response.json()
-
-
-def receive_certificate_by_token(domain: str, token: str, csr: str) -> str:
-    """Get user info from the Cloud by user certificate.
-
-    Args:
-        domain: Domain to request client certificate.
-        token: Authentication  one-time user token.
-        csr: User CSR in PEM format.
-
-    Returns:
-        The user certificate issued by the AosEdge Cloud
-    """
-    try:
-        with ca_certificate() as server_certificate_path:
-            upload_response = post(
-                urljoin(f'https://{domain}', _UPLOAD_USER_CERTIFICATE),
-                json={'csr': csr},
-                headers={
-                    'Content-Type': 'application/json; charset=UTF-8',
-                    'Referer': f'https://{domain}',
-                    'Authorization': f'Token {token}',
-                },
-                verify=server_certificate_path,
-            )
-            if upload_response.status_code == 403:
-                raise INVALID_TOKEN_ERROR
-            upload_response.raise_for_status()
-
-    except SSLError:
-        # Try using system root certificate storage as the trusted sources instead of the AosEdge root certificate
-        upload_response = post(
-            urljoin(f'https://{domain}', _UPLOAD_USER_CERTIFICATE),
-            json={'csr': csr},
-            headers={
-                'Content-Type': 'application/json; charset=UTF-8',
-                'Referer': f'https://{domain}',
-                'Authorization': f'Token {token}',
-            },
-        )
-        if upload_response.status_code == 403:
-            raise INVALID_TOKEN_ERROR
-        upload_response.raise_for_status()
-
-    return upload_response.json()['certificate']
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""aos-keys cloud API implementations."""
+from urllib.parse import urljoin
+
+from requests import post
+from requests.exceptions import SSLError
+
+from aos_keys.common import ca_certificate, AosKeysError
+from aos_keys.crypto_container import AosCryptoContainer
+from aos_keys.key_manager import extract_cloud_domain_from_cert
+
+
+_ME_CERT_ENDPOINT = '/api/v3/users/me/'
+_UPLOAD_USER_CERTIFICATE = '/api/v3/user-certificates/'
+
+
+INVALID_TOKEN_ERROR = AosKeysError(
+    'FORBIDDEN status was received from the AosEdge Cloud!',
+    help_text='Access token is wrong or already used',
+)
+
+
+def get_user_info_by_cert(pkcs12_path: str):
+    """Get user info from the Cloud by user certificate.
+
+    Args:
+        pkcs12_path: Full path to user certificate in pkcs12 format.
+
+    Returns:
+        Json response from cloud
+    """
+    domain = extract_cloud_domain_from_cert(pkcs12_path)
+    with ca_certificate() as server_certificate_path:
+        with AosCryptoContainer(pkcs12_path).create_requests_session() as session:
+            response = session.get(
+                urljoin(f'https://{domain}:10000', _ME_CERT_ENDPOINT),
+                verify=server_certificate_path,
+            )
+            response.raise_for_status()
+            return response.json()
+
+
+def receive_certificate_by_token(domain: str, token: str, csr: str) -> str:
+    """Get user info from the Cloud by user certificate.
+
+    Args:
+        domain: Domain to request client certificate.
+        token: Authentication  one-time user token.
+        csr: User CSR in PEM format.
+
+    Returns:
+        The user certificate issued by the AosEdge Cloud
+    """
+    try:
+        with ca_certificate() as server_certificate_path:
+            upload_response = post(
+                urljoin(f'https://{domain}', _UPLOAD_USER_CERTIFICATE),
+                json={'csr': csr},
+                headers={
+                    'Content-Type': 'application/json; charset=UTF-8',
+                    'Referer': f'https://{domain}',
+                    'Authorization': f'Token {token}',
+                },
+                verify=server_certificate_path,
+            )
+            if upload_response.status_code == 403:
+                raise INVALID_TOKEN_ERROR
+            upload_response.raise_for_status()
+
+    except SSLError:
+        # Try using system root certificate storage as the trusted sources instead of the AosEdge root certificate
+        upload_response = post(
+            urljoin(f'https://{domain}', _UPLOAD_USER_CERTIFICATE),
+            json={'csr': csr},
+            headers={
+                'Content-Type': 'application/json; charset=UTF-8',
+                'Referer': f'https://{domain}',
+                'Authorization': f'Token {token}',
+            },
+        )
+        if upload_response.status_code == 403:
+            raise INVALID_TOKEN_ERROR
+        upload_response.raise_for_status()
+
+    return upload_response.json()['certificate']
```

## aos_keys/common.py

```diff
@@ -1,132 +1,149 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""Common defaults and settings."""
-
-import sys
-from contextlib import contextmanager
-from enum import Enum
-from pathlib import Path
-from typing import Iterable
-
-from rich.console import Console
-
-if sys.version_info > (3, 9):
-    from importlib import resources as pkg_resources  # noqa: WPS433, WPS440
-else:
-    import importlib_resources as pkg_resources  # noqa: WPS433, WPS440
-
-DEFAULT_CREDENTIALS_PATH = Path.home() / '.aos' / 'security'
-DEFAULT_CREDENTIALS_FOLDER = str(DEFAULT_CREDENTIALS_PATH)
-
-DEFAULT_OEM_FILE_NAME = 'aos-user-oem.p12'
-DEFAULT_FLEET_FILE_NAME = 'aos-user-fleet.p12'
-DEFAULT_SP_FILE_NAME = 'aos-user-sp.p12'
-DEFAULT_ADMIN_FILE_NAME = 'aos-user-admin.p12'
-
-DEFAULT_OEM_PATH = str(DEFAULT_CREDENTIALS_PATH / DEFAULT_OEM_FILE_NAME)
-DEFAULT_SP_PATH = str(DEFAULT_CREDENTIALS_PATH / DEFAULT_SP_FILE_NAME)
-
-FILES_DIR = 'aos_keys'
-ROOT_CA_CERT_FILENAME = 'files/1rootCA.crt'
-
-console = Console()
-
-
-@contextmanager
-def ca_certificate():
-    """
-    Aos root certificate to verify server certificate.
-
-    Yields:
-        server_certificate_path: Path to certificate file.
-    """
-    server_certificate = pkg_resources.files(FILES_DIR) / ROOT_CA_CERT_FILENAME
-    with pkg_resources.as_file(server_certificate) as server_certificate_path:
-        yield server_certificate_path
-
-
-def _print_help_with_spaces(text):
-    console.print(f'  {text}')
-
-
-class AosKeysError(Exception):
-    """Exception with help text with recommended user actions."""
-
-    def __init__(self, message, help_text=None):
-        """Exception with help text with recommended user actions.
-
-        Args:
-            message: Exception message.
-            help_text: Help text to print after error.
-        """
-        super().__init__(message)
-        self.help_text = help_text
-
-    def print_message(self):
-        """Print exception with help text if existed."""
-        console.print(f'ERROR: {self}', style='red')
-
-        if not self.help_text:
-            return
-
-        if isinstance(self.help_text, str) or not isinstance(self.help_text, Iterable):
-            _print_help_with_spaces(self.help_text)
-            return
-
-        for row in self.help_text:
-            _print_help_with_spaces(row)
-
-
-class UserType(Enum):
-    """Supported user types."""
-
-    SP = 'sp'  # noqa: WPS115
-    OEM = 'oem'  # noqa: WPS115
-    FLEET = 'fleet'  # noqa: WPS115
-    ADMIN = 'admin'  # noqa: WPS115
-
-    @property
-    def default_user_certificate_path(self) -> Path:
-        """Absolute path to default certificate file.
-
-        Returns:
-            (Path): Path to certificate filename.
-        """
-        return DEFAULT_CREDENTIALS_PATH / self.default_file_name
-
-    @property
-    def default_file_name(self) -> str:
-        """Return default certificate file name for selecter user type.
-
-        Returns:
-            (str): Certificate filename.
-        """
-        if self.value == 'sp':
-            return DEFAULT_SP_FILE_NAME
-        elif self.value == 'oem':
-            return DEFAULT_OEM_FILE_NAME
-        elif self.value == 'fleet':
-            return DEFAULT_FLEET_FILE_NAME
-        elif self.value == 'admin':
-            return DEFAULT_ADMIN_FILE_NAME
-
-    @classmethod
-    def from_input(cls, received_val: str):
-        """Create user type from command input.
-
-        Args:
-            received_val (str): received parameter.
-
-        Returns:
-            (UserType): Instantiated UserType.
-
-        Raises:
-            AosKeysError: If received unknown parameter.
-        """
-        prepared = received_val.strip(' -').upper()
-        try:
-            return cls[prepared]
-        except KeyError:
-            raise AosKeysError(f'Received unsupported user type: [bold]{prepared}[/bold]')
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""Common defaults and settings."""
+
+import sys
+from contextlib import contextmanager
+from enum import Enum
+from pathlib import Path
+from typing import Iterable
+
+from rich.console import Console
+
+if sys.version_info > (3, 9):
+    from importlib import resources as pkg_resources  # noqa: WPS433, WPS440
+else:
+    import importlib_resources as pkg_resources  # noqa: WPS433, WPS440
+
+DEFAULT_CREDENTIALS_PATH = Path.home() / '.aos' / 'security'
+DEFAULT_CREDENTIALS_FOLDER = str(DEFAULT_CREDENTIALS_PATH)
+
+DEFAULT_OEM_FILE_NAME = 'aos-user-oem.p12'
+DEFAULT_FLEET_FILE_NAME = 'aos-user-fleet.p12'
+DEFAULT_SP_FILE_NAME = 'aos-user-sp.p12'
+DEFAULT_ADMIN_FILE_NAME = 'aos-user-admin.p12'
+
+DEFAULT_OEM_PATH = str(DEFAULT_CREDENTIALS_PATH / DEFAULT_OEM_FILE_NAME)
+DEFAULT_SP_PATH = str(DEFAULT_CREDENTIALS_PATH / DEFAULT_SP_FILE_NAME)
+
+FILES_DIR = 'aos_keys'
+ROOT_CA_CERT_FILENAME = 'files/1rootCA.crt'
+
+console = Console()
+error_console = Console(stderr=True, style='red')
+allow_print = True
+
+
+def print_success(message):
+    if allow_print:
+        print_message(f'[green]{str(message)}')
+
+def print_error(message):
+    if allow_print:
+        error_console.print(message)
+
+def print_message(formatted_text, end="\n", ljust: int = 0):
+    if allow_print:
+        if ljust > 0:
+            formatted_text = formatted_text.ljust(ljust)
+        console.print(formatted_text, end=end)
+
+@contextmanager
+def ca_certificate():
+    """
+    Aos root certificate to verify server certificate.
+
+    Yields:
+        server_certificate_path: Path to certificate file.
+    """
+    server_certificate = pkg_resources.files(FILES_DIR) / ROOT_CA_CERT_FILENAME
+    with pkg_resources.as_file(server_certificate) as server_certificate_path:
+        yield server_certificate_path
+
+
+def _print_help_with_spaces(text):
+    if allow_print:
+        print_error(f'  {text}')
+
+
+class AosKeysError(Exception):
+    """Exception with help text with recommended user actions."""
+
+    def __init__(self, message, help_text=None):
+        """Exception with help text with recommended user actions.
+
+        Args:
+            message: Exception message.
+            help_text: Help text to print after error.
+        """
+        super().__init__(message)
+        self.help_text = help_text
+
+    def print_message(self):
+        """Print exception with help text if existed."""
+        print_error(f'ERROR: {self}')
+
+        if not self.help_text:
+            return
+
+        if isinstance(self.help_text, str) or not isinstance(self.help_text, Iterable):
+            _print_help_with_spaces(self.help_text)
+            return
+
+        for row in self.help_text:
+            _print_help_with_spaces(row)
+
+
+class UserType(Enum):
+    """Supported user types."""
+
+    SP = 'sp'  # noqa: WPS115
+    OEM = 'oem'  # noqa: WPS115
+    FLEET = 'fleet'  # noqa: WPS115
+    ADMIN = 'admin'  # noqa: WPS115
+
+    @property
+    def default_user_certificate_path(self) -> Path:
+        """Absolute path to default certificate file.
+
+        Returns:
+            (Path): Path to certificate filename.
+        """
+        return DEFAULT_CREDENTIALS_PATH / self.default_file_name
+
+    @property
+    def default_file_name(self) -> str:
+        """Return default certificate file name for selecter user type.
+
+        Returns:
+            (str): Certificate filename.
+        """
+        if self.value == 'sp':
+            return DEFAULT_SP_FILE_NAME
+        elif self.value == 'oem':
+            return DEFAULT_OEM_FILE_NAME
+        elif self.value == 'fleet':
+            return DEFAULT_FLEET_FILE_NAME
+        elif self.value == 'admin':
+            return DEFAULT_ADMIN_FILE_NAME
+
+    @classmethod
+    def from_input(cls, received_val: str):
+        """Create user type from command input.
+
+        Args:
+            received_val (str): received parameter.
+
+        Returns:
+            (UserType): Instantiated UserType.
+
+        Raises:
+            AosKeysError: If received unknown parameter.
+        """
+        prepared = received_val.strip(' -').upper()
+        try:
+            return cls[prepared]
+        except KeyError:
+            raise AosKeysError(f'Received unsupported user type: [bold]{prepared}[/bold]')
```

## aos_keys/crypto_container.py

 * *Ordering differences only*

```diff
@@ -1,127 +1,127 @@
-import os
-import ssl
-import typing
-
-import requests
-from requests.adapters import HTTPAdapter
-from pathlib import Path
-from cryptography.hazmat.primitives import serialization
-from cryptography.hazmat.primitives.serialization import pkcs12, load_pem_private_key
-
-from aos_keys.common import AosKeysError
-
-
-PRIVATE_KEY_ABSENT_ERROR = AosKeysError(
-    'Key container does not have private key',
-    help_text='Container with key and certificates does not contain all items. Recreate key for the user.',
-)
-
-CERTIFICATE_ABSENT_ERROR = AosKeysError(
-    'Key container does not have all needed certificates',
-    help_text='Container with key and certificates does not contain all items. Recreate key for the user.',
-)
-
-
-class MTLSAdapter(HTTPAdapter):
-
-    def __init__(self, *args, **kwargs):
-        self._ssl_context = None
-        crypto_instance = kwargs.pop('aos_crypto_container', None)
-        if crypto_instance:
-            self._ssl_context = crypto_instance.create_ssl_context()
-        super().__init__(*args, **kwargs)
-
-    def init_poolmanager(self, *args, **kwargs):
-        if self._ssl_context:
-            kwargs['ssl_context'] = self._ssl_context
-        return super().init_poolmanager(*args, **kwargs)
-
-    def proxy_manager_for(self, *args, **kwargs):
-        if self._ssl_context:
-            kwargs['ssl_context'] = self._ssl_context
-        return super().proxy_manager_for(*args, **kwargs)
-
-
-class AosCryptoContainer:
-
-    def __init__(self, file_path: typing.Union[str, os.PathLike]):
-        self._p12_filename: typing.Optional[str] = None
-        self._pem_filename: typing.Optional[str] = None
-        self._p12_bytes: typing.Optional[bytes] = None
-        self._pem_bytes: typing.Optional[bytes] = None
-        self._key_and_certificates: typing.Optional[pkcs12.PKCS12KeyAndCertificates] = None
-
-        self.base_filename = file_path
-        self.load()
-
-    @property
-    def base_filename(self):
-        return str(Path(self._p12_filename).with_suffix(''))
-
-    @base_filename.setter
-    def base_filename(self, filename: typing.Union[str, os.PathLike]):
-        # Remove ext from filename
-        filename_no_ext = Path(filename).with_suffix('')
-        self._p12_filename = str(filename)
-        self._pem_filename = str(Path(filename_no_ext).with_suffix('.pem'))
-        if self._pem_filename == self._p12_filename:
-            self._pem_filename += '.pem'
-
-    def load(self):
-        if not os.path.exists(self._p12_filename):
-            return
-
-        # Load key and certificates
-        with open(self._p12_filename, 'rb') as p12_handle:
-            self._p12_bytes = p12_handle.read()
-        self._key_and_certificates = pkcs12.load_pkcs12(self._p12_bytes, None)
-
-        if not self._key_and_certificates.key:
-            raise PRIVATE_KEY_ABSENT_ERROR
-
-        if not (self._key_and_certificates.cert and self._key_and_certificates.additional_certs):
-            raise CERTIFICATE_ABSENT_ERROR
-
-        self._create_pem()
-        self._check_pem()
-
-    def create_ssl_context(self):
-        ssl_ctx = ssl.create_default_context()
-        if os.path.exists(self._pem_filename):
-            ssl_ctx.load_cert_chain(self._pem_filename, password=None)
-        return ssl_ctx
-
-    def create_requests_session(self):
-        https_session = requests.session()
-        https_session.mount('https://', MTLSAdapter(aos_crypto_container=self))
-        return https_session
-
-    def _create_pem(self, force_recreate: bool = False):
-        if os.path.exists(self._pem_filename) and not force_recreate:
-            return
-
-        with open(self._pem_filename, 'wb') as pem_handle:
-            pem_handle.write(self._dump_to_pem())
-
-    def _dump_to_pem(self) -> bytes:
-        pem_list = [
-            self._key_and_certificates.key.private_bytes(
-                serialization.Encoding.PEM,
-                serialization.PrivateFormat.TraditionalOpenSSL,
-                serialization.NoEncryption(),
-            ),
-            self._key_and_certificates.cert.certificate.public_bytes(serialization.Encoding.PEM),
-        ]
-        for cert in self._key_and_certificates.additional_certs:
-            pem_list.append(
-                cert.certificate.public_bytes(serialization.Encoding.PEM),
-            )
-        return b''.join(pem_list)
-
-    def _check_pem(self):
-        with open(self._pem_filename, 'rb') as pem_handle:
-            self._pem_bytes = pem_handle.read()
-
-        if self._pem_bytes != self._dump_to_pem():
-            # Need to recreate PEM
-            self._create_pem(force_recreate=True)
+import os
+import ssl
+import typing
+
+import requests
+from requests.adapters import HTTPAdapter
+from pathlib import Path
+from cryptography.hazmat.primitives import serialization
+from cryptography.hazmat.primitives.serialization import pkcs12, load_pem_private_key
+
+from aos_keys.common import AosKeysError
+
+
+PRIVATE_KEY_ABSENT_ERROR = AosKeysError(
+    'Key container does not have private key',
+    help_text='Container with key and certificates does not contain all items. Recreate key for the user.',
+)
+
+CERTIFICATE_ABSENT_ERROR = AosKeysError(
+    'Key container does not have all needed certificates',
+    help_text='Container with key and certificates does not contain all items. Recreate key for the user.',
+)
+
+
+class MTLSAdapter(HTTPAdapter):
+
+    def __init__(self, *args, **kwargs):
+        self._ssl_context = None
+        crypto_instance = kwargs.pop('aos_crypto_container', None)
+        if crypto_instance:
+            self._ssl_context = crypto_instance.create_ssl_context()
+        super().__init__(*args, **kwargs)
+
+    def init_poolmanager(self, *args, **kwargs):
+        if self._ssl_context:
+            kwargs['ssl_context'] = self._ssl_context
+        return super().init_poolmanager(*args, **kwargs)
+
+    def proxy_manager_for(self, *args, **kwargs):
+        if self._ssl_context:
+            kwargs['ssl_context'] = self._ssl_context
+        return super().proxy_manager_for(*args, **kwargs)
+
+
+class AosCryptoContainer:
+
+    def __init__(self, file_path: typing.Union[str, os.PathLike]):
+        self._p12_filename: typing.Optional[str] = None
+        self._pem_filename: typing.Optional[str] = None
+        self._p12_bytes: typing.Optional[bytes] = None
+        self._pem_bytes: typing.Optional[bytes] = None
+        self._key_and_certificates: typing.Optional[pkcs12.PKCS12KeyAndCertificates] = None
+
+        self.base_filename = file_path
+        self.load()
+
+    @property
+    def base_filename(self):
+        return str(Path(self._p12_filename).with_suffix(''))
+
+    @base_filename.setter
+    def base_filename(self, filename: typing.Union[str, os.PathLike]):
+        # Remove ext from filename
+        filename_no_ext = Path(filename).with_suffix('')
+        self._p12_filename = str(filename)
+        self._pem_filename = str(Path(filename_no_ext).with_suffix('.pem'))
+        if self._pem_filename == self._p12_filename:
+            self._pem_filename += '.pem'
+
+    def load(self):
+        if not os.path.exists(self._p12_filename):
+            return
+
+        # Load key and certificates
+        with open(self._p12_filename, 'rb') as p12_handle:
+            self._p12_bytes = p12_handle.read()
+        self._key_and_certificates = pkcs12.load_pkcs12(self._p12_bytes, None)
+
+        if not self._key_and_certificates.key:
+            raise PRIVATE_KEY_ABSENT_ERROR
+
+        if not (self._key_and_certificates.cert and self._key_and_certificates.additional_certs):
+            raise CERTIFICATE_ABSENT_ERROR
+
+        self._create_pem()
+        self._check_pem()
+
+    def create_ssl_context(self):
+        ssl_ctx = ssl.create_default_context()
+        if os.path.exists(self._pem_filename):
+            ssl_ctx.load_cert_chain(self._pem_filename, password=None)
+        return ssl_ctx
+
+    def create_requests_session(self):
+        https_session = requests.session()
+        https_session.mount('https://', MTLSAdapter(aos_crypto_container=self))
+        return https_session
+
+    def _create_pem(self, force_recreate: bool = False):
+        if os.path.exists(self._pem_filename) and not force_recreate:
+            return
+
+        with open(self._pem_filename, 'wb') as pem_handle:
+            pem_handle.write(self._dump_to_pem())
+
+    def _dump_to_pem(self) -> bytes:
+        pem_list = [
+            self._key_and_certificates.key.private_bytes(
+                serialization.Encoding.PEM,
+                serialization.PrivateFormat.TraditionalOpenSSL,
+                serialization.NoEncryption(),
+            ),
+            self._key_and_certificates.cert.certificate.public_bytes(serialization.Encoding.PEM),
+        ]
+        for cert in self._key_and_certificates.additional_certs:
+            pem_list.append(
+                cert.certificate.public_bytes(serialization.Encoding.PEM),
+            )
+        return b''.join(pem_list)
+
+    def _check_pem(self):
+        with open(self._pem_filename, 'rb') as pem_handle:
+            self._pem_bytes = pem_handle.read()
+
+        if self._pem_bytes != self._dump_to_pem():
+            # Need to recreate PEM
+            self._create_pem(force_recreate=True)
```

## aos_keys/key_manager.py

```diff
@@ -1,171 +1,170 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""aos-keys certificates manager module."""
-from cryptography.hazmat.backends import default_backend
-from cryptography.hazmat.primitives.asymmetric import ec, rsa
-from cryptography.hazmat.primitives.hashes import SHA256
-from cryptography.hazmat.primitives.serialization import load_pem_private_key, NoEncryption, Encoding, PrivateFormat
-from cryptography.hazmat.primitives.serialization.pkcs12 import serialize_key_and_certificates, load_pkcs12
-from cryptography.x509 import load_pem_x509_certificate, Name, CertificateSigningRequestBuilder
-from cryptography.x509.oid import NameOID
-from datetime import datetime
-from rich.table import Table
-
-from aos_keys.common import console, AosKeysError
-
-_CERTIFICATE_START = b'-----BEGIN CERTIFICATE-----'
-
-
-def _print_cert_field(table, caption: str, certificate, oid):
-    """
-    Print certificate filed in console table.
-
-    Args:
-        table: Table object.
-        caption (str): row caption.
-        certificate: Certificate object.
-        oid: Oid to print.
-    """
-    if certificate.subject.get_attributes_for_oid(oid):
-        table.add_row(caption, certificate.subject.get_attributes_for_oid(oid)[0].value)
-
-
-def _split_certificate_chain(pem_bytes: bytes):
-    """
-    Split certificate chain to user certificate and other certificates.
-
-    Args:
-        pem_bytes (bytes): certificate chain in PEM container.
-
-    Returns:
-        user certificate, other certificates chain: Tuple of user certificate and chain
-    """
-    pem_certs_split = pem_bytes.split(_CERTIFICATE_START)
-    pem_certs_split = list(filter(None, pem_certs_split))
-    user_certificate = load_pem_x509_certificate(_CERTIFICATE_START + pem_certs_split[0])
-    other_certificates = []
-    for single_pem_cert in pem_certs_split[1:]:
-        cert = load_pem_x509_certificate((_CERTIFICATE_START + single_pem_cert))
-        other_certificates.append(cert)
-
-    return user_certificate, other_certificates
-
-
-def generate_pair(use_elliptic_curves=True):
-    """
-    Generate private key and CSR.
-
-    Args:
-        use_elliptic_curves: use elliptic curves if true.
-
-    Returns:
-        (private_key, csr): private_key and csr bytes
-    """
-    if use_elliptic_curves:
-        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
-    else:
-        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)  # noqa: WPS432
-
-    private_key_pem_bytes = private_key.private_bytes(
-        encoding=Encoding.PEM,
-        format=PrivateFormat.PKCS8,
-        encryption_algorithm=NoEncryption(),
-    )
-    empty_subject_name = Name([])
-    csr = CertificateSigningRequestBuilder().subject_name(empty_subject_name).sign(private_key, SHA256())
-    return private_key_pem_bytes, csr.public_bytes(Encoding.PEM)
-
-
-def extract_cloud_domain_from_cert(cert_file_path: str) -> str:
-    """
-    Get the Cloud domain name from user certificate.
-
-    Args:
-        cert_file_path: path to user certificate.
-
-    Returns:
-        Domain name in ORGANIZATION_NAME field
-    """
-    with open(cert_file_path, 'rb') as cert:
-        certificate = load_pkcs12(cert.read(), password=None).cert.certificate
-        org_list = certificate.subject.get_attributes_for_oid(NameOID.ORGANIZATION_NAME)
-        if org_list:
-            return org_list[0].value
-        return 'aoscloud.io'
-
-
-def datetime_from_utc_to_local(utc_datetime):
-    now_aware = datetime.now().astimezone()
-    return utc_datetime.astimezone().isoformat(' ', 'seconds')
-
-
-def print_cert_info(cert_file_path: str) -> None:
-    """
-    Print information about user certificate.
-
-    Args:
-        cert_file_path: path to user certificate.
-
-    Raises:
-        AosKeysError: If user certificate not found.
-    """
-    try:
-        with open(cert_file_path, 'rb') as cert:
-            certificate = load_pkcs12(cert.read(), password=None).cert.certificate
-    except FileNotFoundError as not_found:
-        raise AosKeysError(f'Certificate file {cert_file_path} not found!') from not_found
-
-    table = Table(padding=0, title='Certificate info', show_header=False)
-    table.add_column('', no_wrap=True, justify='left', style='bold')
-    table.add_column('', style='bold')
-    table.add_row('File: ', cert_file_path)
-    _print_cert_field(table, 'Aos base domain: ', certificate, NameOID.ORGANIZATION_NAME)
-    table.add_row('Serial number: ', f'{certificate.serial_number:X}')
-    _print_cert_field(table, 'User: ', certificate, NameOID.COMMON_NAME)
-    _print_cert_field(table, 'e-mail: ', certificate, NameOID.EMAIL_ADDRESS)
-    _print_cert_field(table, 'Company name: ', certificate, NameOID.ORGANIZATIONAL_UNIT_NAME)
-    table.add_row('Valid not before: ', str(datetime_from_utc_to_local(certificate.not_valid_before)))
-    table.add_row('Valid not after: ', str(datetime_from_utc_to_local(certificate.not_valid_after)))
-    console.print(table)
-
-
-def pem_to_pkcs12_bytes(private_key_pem: bytes, certificate_pem: bytes, friendly_name: str) -> bytes:
-    """
-    Create pkcs12 container from private key and certificate.
-
-    Args:
-        private_key_pem: Private key.
-        certificate_pem: Certificate.
-        friendly_name: Friendly name for certificate
-
-    Returns:
-        pkcs12 container
-    """
-    key = load_pem_private_key(private_key_pem, None)
-    user_cert, other_certs = _split_certificate_chain(certificate_pem)
-    return serialize_key_and_certificates(
-        name=friendly_name.encode('utf-8'),
-        key=key,
-        cert=user_cert,
-        cas=other_certs,
-        encryption_algorithm=NoEncryption(),
-    )
-
-
-def pkcs12_to_pem_bytes(pkcs12_bytes: bytes) -> (bytes, bytes):
-    """
-    Get PKCS12 bytes and return PEM certificates chain and key.
-
-    Args:
-        pkcs12_bytes (bytes): pkcs12 container.
-
-    Returns:
-        key (bytes), certificate (bytes): PEM key and certificate
-    """
-    pkcs12 = load_pkcs12(pkcs12_bytes, password=None)
-    certs = [pkcs12.cert, *pkcs12.additional_certs]
-    cert_bytes = b''.join([cert.certificate.public_bytes(Encoding.PEM) for cert in certs])
-
-    return pkcs12.key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()), cert_bytes
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""aos-keys certificates manager module."""
+from cryptography.hazmat.backends import default_backend
+from cryptography.hazmat.primitives.asymmetric import ec, rsa
+from cryptography.hazmat.primitives.hashes import SHA256
+from cryptography.hazmat.primitives.serialization import load_pem_private_key, NoEncryption, Encoding, PrivateFormat
+from cryptography.hazmat.primitives.serialization.pkcs12 import serialize_key_and_certificates, load_pkcs12
+from cryptography.x509 import load_pem_x509_certificate, Name, CertificateSigningRequestBuilder
+from cryptography.x509.oid import NameOID
+from datetime import datetime
+from rich.table import Table
+
+from aos_keys.common import console, AosKeysError
+
+_CERTIFICATE_START = b'-----BEGIN CERTIFICATE-----'
+
+
+def _print_cert_field(table, caption: str, certificate, oid):
+    """
+    Print certificate filed in console table.
+
+    Args:
+        table: Table object.
+        caption (str): row caption.
+        certificate: Certificate object.
+        oid: Oid to print.
+    """
+    if certificate.subject.get_attributes_for_oid(oid):
+        table.add_row(caption, certificate.subject.get_attributes_for_oid(oid)[0].value)
+
+
+def _split_certificate_chain(pem_bytes: bytes):
+    """
+    Split certificate chain to user certificate and other certificates.
+
+    Args:
+        pem_bytes (bytes): certificate chain in PEM container.
+
+    Returns:
+        user certificate, other certificates chain: Tuple of user certificate and chain
+    """
+    pem_certs_split = pem_bytes.split(_CERTIFICATE_START)
+    pem_certs_split = list(filter(None, pem_certs_split))
+    user_certificate = load_pem_x509_certificate(_CERTIFICATE_START + pem_certs_split[0])
+    other_certificates = []
+    for single_pem_cert in pem_certs_split[1:]:
+        cert = load_pem_x509_certificate((_CERTIFICATE_START + single_pem_cert))
+        other_certificates.append(cert)
+
+    return user_certificate, other_certificates
+
+
+def generate_pair(use_elliptic_curves=True):
+    """
+    Generate private key and CSR.
+
+    Args:
+        use_elliptic_curves: use elliptic curves if true.
+
+    Returns:
+        (private_key, csr): private_key and csr bytes
+    """
+    if use_elliptic_curves:
+        private_key = ec.generate_private_key(ec.SECP256R1(), default_backend())
+    else:
+        private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)  # noqa: WPS432
+
+    private_key_pem_bytes = private_key.private_bytes(
+        encoding=Encoding.PEM,
+        format=PrivateFormat.PKCS8,
+        encryption_algorithm=NoEncryption(),
+    )
+    empty_subject_name = Name([])
+    csr = CertificateSigningRequestBuilder().subject_name(empty_subject_name).sign(private_key, SHA256())
+    return private_key_pem_bytes, csr.public_bytes(Encoding.PEM)
+
+
+def extract_cloud_domain_from_cert(cert_file_path: str) -> str:
+    """
+    Get the Cloud domain name from user certificate.
+
+    Args:
+        cert_file_path: path to user certificate.
+
+    Returns:
+        Domain name in ORGANIZATION_NAME field
+    """
+    with open(cert_file_path, 'rb') as cert:
+        certificate = load_pkcs12(cert.read(), password=None).cert.certificate
+        org_list = certificate.subject.get_attributes_for_oid(NameOID.ORGANIZATION_NAME)
+        if org_list:
+            return org_list[0].value
+        return 'aoscloud.io'
+
+
+def datetime_from_utc_to_local(utc_datetime):
+    return utc_datetime.astimezone().isoformat(' ', 'seconds')
+
+
+def print_cert_info(cert_file_path: str) -> None:
+    """
+    Print information about user certificate.
+
+    Args:
+        cert_file_path: path to user certificate.
+
+    Raises:
+        AosKeysError: If user certificate not found.
+    """
+    try:
+        with open(cert_file_path, 'rb') as cert:
+            certificate = load_pkcs12(cert.read(), password=None).cert.certificate
+    except FileNotFoundError as not_found:
+        raise AosKeysError(f'Certificate file {cert_file_path} not found!') from not_found
+
+    table = Table(padding=0, title='Certificate info', show_header=False)
+    table.add_column('', no_wrap=True, justify='left', style='bold')
+    table.add_column('', style='bold')
+    table.add_row('File: ', cert_file_path)
+    _print_cert_field(table, 'Aos base domain: ', certificate, NameOID.ORGANIZATION_NAME)
+    table.add_row('Serial number: ', f'{certificate.serial_number:X}')
+    _print_cert_field(table, 'User: ', certificate, NameOID.COMMON_NAME)
+    _print_cert_field(table, 'e-mail: ', certificate, NameOID.EMAIL_ADDRESS)
+    _print_cert_field(table, 'Company name: ', certificate, NameOID.ORGANIZATIONAL_UNIT_NAME)
+    table.add_row('Valid not before: ', str(datetime_from_utc_to_local(certificate.not_valid_before)))
+    table.add_row('Valid not after: ', str(datetime_from_utc_to_local(certificate.not_valid_after)))
+    console.print(table)
+
+
+def pem_to_pkcs12_bytes(private_key_pem: bytes, certificate_pem: bytes, friendly_name: str) -> bytes:
+    """
+    Create pkcs12 container from private key and certificate.
+
+    Args:
+        private_key_pem: Private key.
+        certificate_pem: Certificate.
+        friendly_name: Friendly name for certificate
+
+    Returns:
+        pkcs12 container
+    """
+    key = load_pem_private_key(private_key_pem, None)
+    user_cert, other_certs = _split_certificate_chain(certificate_pem)
+    return serialize_key_and_certificates(
+        name=friendly_name.encode('utf-8'),
+        key=key,
+        cert=user_cert,
+        cas=other_certs,
+        encryption_algorithm=NoEncryption(),
+    )
+
+
+def pkcs12_to_pem_bytes(pkcs12_bytes: bytes) -> (bytes, bytes):
+    """
+    Get PKCS12 bytes and return PEM certificates chain and key.
+
+    Args:
+        pkcs12_bytes (bytes): pkcs12 container.
+
+    Returns:
+        key (bytes), certificate (bytes): PEM key and certificate
+    """
+    pkcs12 = load_pkcs12(pkcs12_bytes, password=None)
+    certs = [pkcs12.cert, *pkcs12.additional_certs]
+    cert_bytes = b''.join([cert.certificate.public_bytes(Encoding.PEM) for cert in certs])
+
+    return pkcs12.key.private_bytes(Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()), cert_bytes
```

## aos_keys/main.py

```diff
@@ -1,318 +1,318 @@
-#
-#  Copyright (c) 2018-2023 Renesas Inc.
-#  Copyright (c) 2018-2023 EPAM Systems Inc.
-#
-"""aos-keys main module."""
-
-import argparse
-import sys
-
-from aos_keys.actions import (
-    UserType,
-    new_token_user,
-    convert_pkcs12_file_to_pem,
-    install_root_ca,
-    print_user_info,
-    install_user_certificate,
-)
-from aos_keys.common import DEFAULT_CREDENTIALS_FOLDER, console, AosKeysError
-
-try:
-    from importlib.metadata import version, PackageNotFoundError  # noqa: WPS433
-except ImportError:
-    from importlib_metadata import version, PackageNotFoundError  # noqa: WPS433, WPS440
-
-_COMMAND_INFO = 'info'
-_COMMAND_NEW_USER = 'new-user'
-_COMMAND_TO_PEM = 'to-pem'
-_COMMAND_INSTALL_ROOT_CA = 'install-root'
-_COMMAND_INSTALL_CLIENT_CERT = 'install-cert'
-
-
-def _args_to_cert_path(command_params) -> str:
-    """
-    Get path to certificate from received command line parameters.
-
-    Args:
-        command_params: Parameters received from argparse
-
-    Raises:
-        AosKeysError: If not set any parameters.
-
-    Returns:
-        parsed full path to certificate
-    """
-    if command_params.user_type:
-        return str(UserType.from_input(command_params.user_type).default_user_certificate_path)
-    elif command_params.cert_file_name:
-        return command_params.cert_file_name
-
-    raise AosKeysError(
-        'User certificate not specified.',
-        help_text='Use one of --oem, --sp, --fleet, --admin, or -c key',
-    )
-
-
-def _add_new_user_parser(sub_parser):
-    new_user_command = sub_parser.add_parser(_COMMAND_NEW_USER, help='Create new key and receive certificate')
-    new_user_command.set_defaults(func=_new_user_certificate)
-    new_user_command.add_argument(
-        '-o',
-        '--output-dir',
-        dest='output_dir',
-        default=DEFAULT_CREDENTIALS_FOLDER,
-        help='Output directory to save certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-d',
-        '--domain',
-        dest='register_domain',
-        default='aoscloud.io',
-        help='Aos Cloud domain to sign user certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-t',
-        '--token',
-        dest='token',
-        help='Cloud authorization token.',
-    )
-
-    new_user_command.add_argument(
-        '-oem',
-        '--oem',
-        dest='user_type',
-        action='store_const',
-        const='oem',
-        help='Create OEM user key/certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-s',
-        '--sp',
-        dest='user_type',
-        action='store_const',
-        const='sp',
-        help='Create Service Provider user key/certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-f',
-        '--fleet',
-        dest='user_type',
-        action='store_const',
-        const='fleet',
-        help='Create Fleet Owner user key/certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-a',
-        '--admin',
-        dest='user_type',
-        action='store_const',
-        const='admin',
-        help='Create ADMIN user key/certificate.',
-    )
-
-    new_user_command.add_argument(
-        '-e',
-        '--ecc',
-        action='store_true',
-        help='Create ECC key instead of RSA',
-    )
-
-
-def _add_show_cert_info_parser(sub_parser):
-    info_command = sub_parser.add_parser(_COMMAND_INFO, help='Show certificate / user information')
-    info_command.set_defaults(func=_show_certificate_info)
-    info_command.add_argument(
-        '-c',
-        '--certificate',
-        dest='cert_file_name',
-        help='Certificate file to inspect.',
-    )
-    info_command.add_argument(
-        '-s',
-        '--sp',
-        dest='user_type',
-        action='store_const',
-        const='sp',
-        help='Show info of default Service Provider user certificate.',
-    )
-    info_command.add_argument(
-        '-o',
-        '--oem',
-        dest='user_type',
-        action='store_const',
-        const='oem',
-        help='Show info of default OEM user certificate.',
-    )
-
-    info_command.add_argument(
-        '-f',
-        '--fleet',
-        dest='user_type',
-        action='store_const',
-        const='fleet',
-        help='Show info of default Fleet Owner user key/certificate.',
-    )
-
-    info_command.add_argument(
-        '-a',
-        '--admin',
-        dest='user_type',
-        action='store_const',
-        const='admin',
-        help='Show info of default ADMIN user certificate.',
-    )
-
-
-def _add_install_root_cert_parser(sub_parser):
-    ca_command = sub_parser.add_parser(_COMMAND_INSTALL_ROOT_CA, help='Install Aos CA root Certificate.')
-    ca_command.set_defaults(func=_install_root_ca)
-
-
-def _add_install_client_cert_parser(sub_parser):
-    client_cert_command = sub_parser.add_parser(
-        _COMMAND_INSTALL_CLIENT_CERT,
-        help='Install user certificate to browser store',
-    )
-    client_cert_command.set_defaults(func=_install_user_certificate)
-    client_cert_command.add_argument(
-        '-c',
-        '--certificate',
-        dest='cert_file_name',
-        help='Certificate file to inspect.',
-    )
-    client_cert_command.add_argument(
-        '-s',
-        '--sp',
-        dest='user_type',
-        action='store_const',
-        const='sp',
-        help='Show info of default Service Provider user certificate.',
-    )
-    client_cert_command.add_argument(
-        '-o',
-        '--oem',
-        dest='user_type',
-        action='store_const',
-        const='oem',
-        help='Show info of default OEM user certificate.',
-    )
-    client_cert_command.add_argument(
-        '-f',
-        '--fleet',
-        dest='user_type',
-        action='store_const',
-        const='fleet',
-        help='Show info of default Fleet Owner user certificate.',
-    )
-    client_cert_command.add_argument(
-        '-a',
-        '--admin',
-        dest='user_type',
-        action='store_const',
-        const='admin',
-        help='Show info of default ADMIN user certificate.',
-    )
-
-
-def _add_convert_cert_parser(sub_parser):
-    pem_command = sub_parser.add_parser(
-        _COMMAND_TO_PEM,
-        help='Convert pkcs12 container to PEM key and certificates chain.',
-    )
-    pem_command.set_defaults(func=_pkcs12_to_pem)
-    pem_command.add_argument(
-        '-c',
-        '--certificate',
-        dest='cert_file_name',
-        required=True,
-        help='path to pkcs12 file.',
-    )
-    pem_command.add_argument(
-        '-o',
-        '--output-dir',
-        dest='output_dir',
-        default=DEFAULT_CREDENTIALS_FOLDER,
-        help='Output directory to save certificate.',
-    )
-
-
-def _parse_args():
-    """User arguments parser.
-
-    Returns:
-        Parsed arguments.
-    """
-    parser = argparse.ArgumentParser(
-        prog='aos-keys',
-        description='Work with keys. Create new keys, receive certificates, show info',
-        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
-    )
-    sub_parser = parser.add_subparsers(title='Commands')
-    _add_new_user_parser(sub_parser)
-    _add_show_cert_info_parser(sub_parser)
-    _add_convert_cert_parser(sub_parser)
-    _add_install_root_cert_parser(sub_parser)
-    _add_install_client_cert_parser(sub_parser)
-
-    parser.add_argument(
-        '-V',
-        '--version',
-        action='version',
-        version=f'%(prog)s {version("aos-keys")}',   # noqa: WPS323,WPS237
-    )
-
-    return parser
-
-
-def _install_user_certificate(args):
-    install_user_certificate(_args_to_cert_path(args))
-
-
-def _install_root_ca(args):
-    install_root_ca()
-
-
-def _show_certificate_info(args):
-    print_user_info(_args_to_cert_path(args))
-
-
-def _new_user_certificate(args):
-    if not args.user_type:
-        raise AosKeysError('Unknown user type', 'Set one of --sp, --oem or --admin param')
-
-    user_type = UserType.from_input(args.user_type)
-    new_token_user(args.register_domain, args.output_dir, args.token, user_type, args.ecc)
-
-
-def _pkcs12_to_pem(args):
-    convert_pkcs12_file_to_pem(args.cert_file_name, args.output_dir)
-
-
-def main():
-    """Terminal main entry point."""
-    parser = _parse_args()
-    args = parser.parse_args()
-
-    if not hasattr(args, 'func'):   # noqa: WPS421
-        parser.print_help()
-        return
-
-    try:
-        args.func(args)
-    except AosKeysError as ake:
-        ake.print_message()
-        sys.exit(1)
-    except Exception as sce:
-        console.print('Process failed with error: ')
-        console.print(sce)
-        sys.exit(1)
-
-
-if __name__ == '__main__':
-    main()
-    sys.exit(0)
+#
+#  Copyright (c) 2018-2023 Renesas Inc.
+#  Copyright (c) 2018-2023 EPAM Systems Inc.
+#
+"""aos-keys main module."""
+
+import argparse
+import sys
+
+from aos_keys.actions import (
+    UserType,
+    new_token_user,
+    convert_pkcs12_file_to_pem,
+    install_root_ca,
+    print_user_info,
+    install_user_certificate,
+)
+from aos_keys.common import DEFAULT_CREDENTIALS_FOLDER, AosKeysError, print_error
+
+try:
+    from importlib.metadata import version, PackageNotFoundError  # noqa: WPS433
+except ImportError:
+    from importlib_metadata import version, PackageNotFoundError  # noqa: WPS433, WPS440
+
+_COMMAND_INFO = 'info'
+_COMMAND_NEW_USER = 'new-user'
+_COMMAND_TO_PEM = 'to-pem'
+_COMMAND_INSTALL_ROOT_CA = 'install-root'
+_COMMAND_INSTALL_CLIENT_CERT = 'install-cert'
+
+
+def _args_to_cert_path(command_params) -> str:
+    """
+    Get path to certificate from received command line parameters.
+
+    Args:
+        command_params: Parameters received from argparse
+
+    Raises:
+        AosKeysError: If not set any parameters.
+
+    Returns:
+        parsed full path to certificate
+    """
+    if command_params.user_type:
+        return str(UserType.from_input(command_params.user_type).default_user_certificate_path)
+    elif command_params.cert_file_name:
+        return command_params.cert_file_name
+
+    raise AosKeysError(
+        'User certificate not specified.',
+        help_text='Use one of --oem, --sp, --fleet, --admin, or -c key',
+    )
+
+
+def _add_new_user_parser(sub_parser):
+    new_user_command = sub_parser.add_parser(_COMMAND_NEW_USER, help='Create new key and receive certificate')
+    new_user_command.set_defaults(func=_new_user_certificate)
+    new_user_command.add_argument(
+        '-o',
+        '--output-dir',
+        dest='output_dir',
+        default=DEFAULT_CREDENTIALS_FOLDER,
+        help='Output directory to save certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-d',
+        '--domain',
+        dest='register_domain',
+        default='aoscloud.io',
+        help='Aos Cloud domain to sign user certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-t',
+        '--token',
+        dest='token',
+        help='Cloud authorization token.',
+    )
+
+    new_user_command.add_argument(
+        '-oem',
+        '--oem',
+        dest='user_type',
+        action='store_const',
+        const='oem',
+        help='Create OEM user key/certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-s',
+        '--sp',
+        dest='user_type',
+        action='store_const',
+        const='sp',
+        help='Create Service Provider user key/certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-f',
+        '--fleet',
+        dest='user_type',
+        action='store_const',
+        const='fleet',
+        help='Create Fleet Owner user key/certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-a',
+        '--admin',
+        dest='user_type',
+        action='store_const',
+        const='admin',
+        help='Create ADMIN user key/certificate.',
+    )
+
+    new_user_command.add_argument(
+        '-e',
+        '--ecc',
+        action='store_true',
+        help='Create ECC key instead of RSA',
+    )
+
+
+def _add_show_cert_info_parser(sub_parser):
+    info_command = sub_parser.add_parser(_COMMAND_INFO, help='Show certificate / user information')
+    info_command.set_defaults(func=_show_certificate_info)
+    info_command.add_argument(
+        '-c',
+        '--certificate',
+        dest='cert_file_name',
+        help='Certificate file to inspect.',
+    )
+    info_command.add_argument(
+        '-s',
+        '--sp',
+        dest='user_type',
+        action='store_const',
+        const='sp',
+        help='Show info of default Service Provider user certificate.',
+    )
+    info_command.add_argument(
+        '-o',
+        '--oem',
+        dest='user_type',
+        action='store_const',
+        const='oem',
+        help='Show info of default OEM user certificate.',
+    )
+
+    info_command.add_argument(
+        '-f',
+        '--fleet',
+        dest='user_type',
+        action='store_const',
+        const='fleet',
+        help='Show info of default Fleet Owner user key/certificate.',
+    )
+
+    info_command.add_argument(
+        '-a',
+        '--admin',
+        dest='user_type',
+        action='store_const',
+        const='admin',
+        help='Show info of default ADMIN user certificate.',
+    )
+
+
+def _add_install_root_cert_parser(sub_parser):
+    ca_command = sub_parser.add_parser(_COMMAND_INSTALL_ROOT_CA, help='Install Aos CA root Certificate.')
+    ca_command.set_defaults(func=_install_root_ca)
+
+
+def _add_install_client_cert_parser(sub_parser):
+    client_cert_command = sub_parser.add_parser(
+        _COMMAND_INSTALL_CLIENT_CERT,
+        help='Install user certificate to browser store',
+    )
+    client_cert_command.set_defaults(func=_install_user_certificate)
+    client_cert_command.add_argument(
+        '-c',
+        '--certificate',
+        dest='cert_file_name',
+        help='Certificate file to inspect.',
+    )
+    client_cert_command.add_argument(
+        '-s',
+        '--sp',
+        dest='user_type',
+        action='store_const',
+        const='sp',
+        help='Show info of default Service Provider user certificate.',
+    )
+    client_cert_command.add_argument(
+        '-o',
+        '--oem',
+        dest='user_type',
+        action='store_const',
+        const='oem',
+        help='Show info of default OEM user certificate.',
+    )
+    client_cert_command.add_argument(
+        '-f',
+        '--fleet',
+        dest='user_type',
+        action='store_const',
+        const='fleet',
+        help='Show info of default Fleet Owner user certificate.',
+    )
+    client_cert_command.add_argument(
+        '-a',
+        '--admin',
+        dest='user_type',
+        action='store_const',
+        const='admin',
+        help='Show info of default ADMIN user certificate.',
+    )
+
+
+def _add_convert_cert_parser(sub_parser):
+    pem_command = sub_parser.add_parser(
+        _COMMAND_TO_PEM,
+        help='Convert pkcs12 container to PEM key and certificates chain.',
+    )
+    pem_command.set_defaults(func=_pkcs12_to_pem)
+    pem_command.add_argument(
+        '-c',
+        '--certificate',
+        dest='cert_file_name',
+        required=True,
+        help='path to pkcs12 file.',
+    )
+    pem_command.add_argument(
+        '-o',
+        '--output-dir',
+        dest='output_dir',
+        default=DEFAULT_CREDENTIALS_FOLDER,
+        help='Output directory to save certificate.',
+    )
+
+
+def _parse_args():
+    """User arguments parser.
+
+    Returns:
+        Parsed arguments.
+    """
+    parser = argparse.ArgumentParser(
+        prog='aos-keys',
+        description='Work with keys. Create new keys, receive certificates, show info',
+        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
+    )
+    sub_parser = parser.add_subparsers(title='Commands')
+    _add_new_user_parser(sub_parser)
+    _add_show_cert_info_parser(sub_parser)
+    _add_convert_cert_parser(sub_parser)
+    _add_install_root_cert_parser(sub_parser)
+    _add_install_client_cert_parser(sub_parser)
+
+    parser.add_argument(
+        '-V',
+        '--version',
+        action='version',
+        version=f'%(prog)s {version("aos-keys")}',   # noqa: WPS323,WPS237
+    )
+
+    return parser
+
+
+def _install_user_certificate(args):
+    install_user_certificate(_args_to_cert_path(args))
+
+
+def _install_root_ca(args):
+    install_root_ca()
+
+
+def _show_certificate_info(args):
+    print_user_info(_args_to_cert_path(args))
+
+
+def _new_user_certificate(args):
+    if not args.user_type:
+        raise AosKeysError('Unknown user type', 'Set one of --sp, --oem or --admin param')
+
+    user_type = UserType.from_input(args.user_type)
+    new_token_user(args.register_domain, args.output_dir, args.token, user_type, args.ecc)
+
+
+def _pkcs12_to_pem(args):
+    convert_pkcs12_file_to_pem(args.cert_file_name, args.output_dir)
+
+
+def main():
+    """Terminal main entry point."""
+    parser = _parse_args()
+    args = parser.parse_args()
+
+    if not hasattr(args, 'func'):   # noqa: WPS421
+        parser.print_help()
+        return
+
+    try:
+        args.func(args)
+    except AosKeysError as ake:
+        ake.print_message()
+        sys.exit(1)
+    except Exception as sce:
+        print_error('Process failed with error: ')
+        print_error(sce)
+        sys.exit(1)
+
+
+if __name__ == '__main__':
+    main()
+    sys.exit(0)
```

## aos_keys/files/1rootCA.crt

```diff
@@ -1,91 +1,93 @@
 00000000: 2d2d 2d2d 2d42 4547 494e 2043 4552 5449  -----BEGIN CERTI
-00000010: 4649 4341 5445 2d2d 2d2d 2d0a 4d49 4945  FICATE-----.MIIE
-00000020: 416a 4343 4175 7167 4177 4942 4167 494a  AjCCAuqgAwIBAgIJ
-00000030: 4150 776b 324e 4666 5344 506a 4d41 3047  APwk2NFfSDPjMA0G
-00000040: 4353 7147 5349 6233 4451 4542 4377 5541  CSqGSIb3DQEBCwUA
-00000050: 4d49 474e 4d52 6377 4651 5944 0a56 5151  MIGNMRcwFQYD.VQQ
-00000060: 4444 4135 4764 584e 7062 3234 6755 6d39  DDA5GdXNpb24gUm9
-00000070: 7664 4342 4451 5445 704d 4363 4743 5371  vdCBDQTEpMCcGCSq
-00000080: 4753 4962 3344 5145 4a41 5259 6164 6d39  GSIb3DQEJARYadm9
-00000090: 7362 3252 3562 586c 7958 324a 680a 596d  sb2R5bXlyX2Jh.Ym
-000000a0: 4e6f 6457 7441 5a58 4268 6253 356a 6232  NodWtAZXBhbS5jb2
-000000b0: 3078 4454 414c 4267 4e56 4241 6f4d 4245  0xDTALBgNVBAoMBE
-000000c0: 5651 5155 3078 4844 4161 4267 4e56 4241  VQQU0xHDAaBgNVBA
-000000d0: 734d 4530 3576 646e 567a 4945 3979 0a5a  sME05vdnVzIE9y.Z
-000000e0: 4738 6755 3256 6a62 4739 7964 5730 7844  G8gU2VjbG9ydW0xD
-000000f0: 5441 4c42 674e 5642 4163 4d42 4574 3561  TALBgNVBAcMBEt5a
-00000100: 5859 7843 7a41 4a42 674e 5642 4159 5441  XYxCzAJBgNVBAYTA
-00000110: 6c56 424d 4234 5844 5445 344d 4451 780a  lVBMB4XDTE4MDQx.
-00000120: 4d44 4578 4d7a 4d77 4d46 6f58 4454 4932  MDExMzMwMFoXDTI2
-00000130: 4d44 5979 4e7a 4578 4d7a 4d77 4d46 6f77  MDYyNzExMzMwMFow
-00000140: 6759 3078 467a 4156 4267 4e56 4241 4d4d  gY0xFzAVBgNVBAMM
-00000150: 446b 5a31 6332 6c76 6269 4253 6232 3930  DkZ1c2lvbiBSb290
-00000160: 0a49 454e 424d 536b 774a 7759 4a4b 6f5a  .IENBMSkwJwYJKoZ
-00000170: 4968 7663 4e41 516b 4246 6870 3262 3278  IhvcNAQkBFhp2b2x
-00000180: 765a 486c 7465 584a 6659 6d46 6959 3268  vZHlteXJfYmFiY2h
-00000190: 3161 3042 6c63 4746 744c 6d4e 7662 5445  1a0BlcGFtLmNvbTE
-000001a0: 4e0a 4d41 7347 4131 5545 4367 7745 5256  N.MAsGA1UECgwERV
-000001b0: 4242 5454 4563 4d42 6f47 4131 5545 4377  BBTTEcMBoGA1UECw
-000001c0: 7754 546d 3932 6458 4d67 5433 4a6b 6279  wTTm92dXMgT3Jkby
-000001d0: 4254 5a57 4e73 6233 4a31 6254 454e 4d41  BTZWNsb3J1bTENMA
-000001e0: 7347 0a41 3155 4542 7777 4553 336c 7064  sG.A1UEBwwES3lpd
-000001f0: 6a45 4c4d 416b 4741 3155 4542 684d 4356  jELMAkGA1UEBhMCV
-00000200: 5545 7767 6745 694d 4130 4743 5371 4753  UEwggEiMA0GCSqGS
-00000210: 4962 3344 5145 4241 5155 4141 3449 4244  Ib3DQEBAQUAA4IBD
-00000220: 7741 770a 6767 454b 416f 4942 4151 432b  wAw.ggEKAoIBAQC+
-00000230: 4b32 6f77 3248 4f37 2b53 5556 664f 7135  K2ow2HO7+SUVfOq5
-00000240: 7454 746d 486a 344c 5169 6a48 4a38 3033  tTtmHj4LQijHJ803
-00000250: 6d4c 6b39 706b 5065 662b 476c 6d65 7970  mLk9pkPef+Glmeyp
-00000260: 3948 5865 0a6a 446c 5143 3034 4d65 6f76  9HXe.jDlQC04Meov
-00000270: 4d42 654e 5461 7130 7769 6266 3771 6173  MBeNTaq0wibf7qas
-00000280: 396e 6958 6265 5852 567a 6865 5a49 467a  9niXbeXRVzheZIFz
-00000290: 694d 5871 5275 774c 7163 304b 5864 4478  iMXqRuwLqc0KXdDx
-000002a0: 4944 5054 620a 5457 334b 3048 4536 4d2f  IDPTb.TW3K0HE6M/
-000002b0: 6541 7454 666e 392b 5a2f 4c6e 6b57 7434  eAtTfn9+Z/LnkWt4
-000002c0: 7a4d 5861 7363 3032 6876 7566 736d 4956  zMXasc02hvufsmIV
-000002d0: 4575 4e62 6331 5668 7273 4a4a 6735 756b  EuNbc1VhrsJJg5uk
-000002e0: 3838 6c64 504d 0a4c 5346 376e 6666 3965  88ldPM.LSF7nff9e
-000002f0: 595a 5448 5967 4379 426b 7439 614c 2b66  YZTHYgCyBkt9aL+f
-00000300: 776f 584f 3665 5344 5341 686a 6f70 5833  woXO6eSDSAhjopX3
-00000310: 6c68 6469 646b 4d2b 6e69 3745 4f68 6c4e  lhdidkM+ni7EOhlN
-00000320: 3753 546d 6744 4d0a 574b 6839 6e4d 6a58  7STmgDM.WKh9nMjX
-00000330: 4435 6632 3850 4768 7457 2f64 5a76 6e34  D5f28PGhtW/dZvn4
-00000340: 537a 6173 5245 354d 6561 4578 496c 426d  SzasRE5MeaExIlBm
-00000350: 686b 5745 5567 5643 7950 374c 7675 5147  hkWEUgVCyP7LvuQG
-00000360: 5255 504b 2b4e 597a 0a46 4532 434c 5275  RUPK+NYz.FE2CLRu
-00000370: 6972 4c43 5779 3148 4974 396c 4c7a 6950  irLCWy1HIt9lLziP
-00000380: 6a6c 5a34 3336 316d 4e41 674d 4241 4147  jlZ4361mNAgMBAAG
-00000390: 6a59 7a42 684d 4230 4741 3155 6444 6751  jYzBhMB0GA1UdDgQ
-000003a0: 5742 4252 3053 6868 7a0a 4f75 4d39 3542  WBBR0Shhz.OuM95B
-000003b0: 6844 306d 5778 4331 6a2b 4b72 4536 556a  hD0mWxC1j+KrE6Uj
-000003c0: 414d 4267 4e56 4852 4d45 4254 4144 4151  AMBgNVHRMEBTADAQ
-000003d0: 482f 4d41 7347 4131 5564 4477 5145 4177  H/MAsGA1UdDwQEAw
-000003e0: 4942 426a 416c 4267 4e56 0a48 5245 4548  IBBjAlBgNV.HREEH
-000003f0: 6a41 6367 5270 3262 3278 765a 486c 7465  jAcgRp2b2xvZHlte
-00000400: 584a 6659 6d46 6959 3268 3161 3042 6c63  XJfYmFiY2h1a0Blc
-00000410: 4746 744c 6d4e 7662 5441 4e42 676b 7168  GFtLmNvbTANBgkqh
-00000420: 6b69 4739 7730 4241 5173 460a 4141 4f43  kiG9w0BAQsF.AAOC
-00000430: 4151 4541 6c38 6276 3148 5459 6533 6c34  AQEAl8bv1HTYe3l4
-00000440: 592b 6730 5456 5a52 3762 594c 3542 4e73  Y+g0TVZR7bYL5BNs
-00000450: 6e47 6771 7930 7153 3566 7539 3931 6b68  nGgqy0qS5fu991kh
-00000460: 5857 662b 5a77 6132 4d4c 566e 0a59 616b  XWf+Zwa2MLVn.Yak
-00000470: 4d6e 4c6b 6a76 6448 7155 7057 4d4a 2f53  MnLkjvdHqUpWMJ/S
-00000480: 3832 6f32 7a57 476d 6d75 7863 6135 3665  82o2zWGmmuxca56e
-00000490: 686a 7843 6950 2f6e 6b6d 344d 3734 7958  hjxCiP/nkm4M74yX
-000004a0: 7a32 5238 6375 3532 5778 596e 460a 794d  z2R8cu52WxYnF.yM
-000004b0: 7667 6177 7a51 3663 3179 6876 5a69 762f  vgawzQ6c1yhvZiv/
-000004c0: 6745 4537 4b64 6259 5256 4b4c 4850 6742  gEE7KdbYRVKLHPgB
-000004d0: 7a66 7975 7032 3169 356e 6753 6c54 634d  zfyup21i5ngSlTcM
-000004e0: 5252 5337 6f4f 426d 6f79 6534 7163 0a36  RRS7oOBmoye4qc.6
-000004f0: 6164 7136 4874 5936 582f 4f6e 5a39 4935  adq6HtY6X/OnZ9I5
-00000500: 786f 524e 3147 6376 614c 5567 5545 3669  xoRN1GcvaLUgUE6i
-00000510: 6754 6956 6131 7046 386b 6564 5768 4859  gTiVa1pF8kedWhHY
-00000520: 3777 7a54 5842 787a 5376 495a 6b43 550a  7wzTXBxzSvIZkCU.
-00000530: 5648 454f 7a76 6147 6b39 6d69 5036 6e42  VHEOzvaGk9miP6nB
-00000540: 7244 664e 7637 6d49 6b67 454b 4152 726a  rDfNv7mIkgEKARrj
-00000550: 6a53 706d 4a61 7349 4555 2b6d 4e74 7a65  jSpmJasIEU+mNtze
-00000560: 4f49 4569 4d74 5731 454d 5263 3435 376f  OIEiMtW1EMRc457o
-00000570: 0a30 5064 4649 336a 7365 794c 5650 5668  .0PdFI3jseyLVPVh
-00000580: 457a 556b 7543 376d 776a 6237 4365 513d  EzUkuC7mwjb7CeQ=
-00000590: 3d0a 2d2d 2d2d 2d45 4e44 2043 4552 5449  =.-----END CERTI
-000005a0: 4649 4341 5445 2d2d 2d2d 2d0a            FICATE-----.
+00000010: 4649 4341 5445 2d2d 2d2d 2d0d 0a4d 4949  FICATE-----..MII
+00000020: 4541 6a43 4341 7571 6741 7749 4241 6749  EAjCCAuqgAwIBAgI
+00000030: 4a41 5077 6b32 4e46 6653 4450 6a4d 4130  JAPwk2NFfSDPjMA0
+00000040: 4743 5371 4753 4962 3344 5145 4243 7755  GCSqGSIb3DQEBCwU
+00000050: 414d 4947 4e4d 5263 7746 5159 440d 0a56  AMIGNMRcwFQYD..V
+00000060: 5151 4444 4135 4764 584e 7062 3234 6755  QQDDA5GdXNpb24gU
+00000070: 6d39 7664 4342 4451 5445 704d 4363 4743  m9vdCBDQTEpMCcGC
+00000080: 5371 4753 4962 3344 5145 4a41 5259 6164  SqGSIb3DQEJARYad
+00000090: 6d39 7362 3252 3562 586c 7958 324a 680d  m9sb2R5bXlyX2Jh.
+000000a0: 0a59 6d4e 6f64 5774 415a 5842 6862 5335  .YmNodWtAZXBhbS5
+000000b0: 6a62 3230 7844 5441 4c42 674e 5642 416f  jb20xDTALBgNVBAo
+000000c0: 4d42 4556 5151 5530 7848 4441 6142 674e  MBEVQQU0xHDAaBgN
+000000d0: 5642 4173 4d45 3035 7664 6e56 7a49 4539  VBAsME05vdnVzIE9
+000000e0: 790d 0a5a 4738 6755 3256 6a62 4739 7964  y..ZG8gU2VjbG9yd
+000000f0: 5730 7844 5441 4c42 674e 5642 4163 4d42  W0xDTALBgNVBAcMB
+00000100: 4574 3561 5859 7843 7a41 4a42 674e 5642  Et5aXYxCzAJBgNVB
+00000110: 4159 5441 6c56 424d 4234 5844 5445 344d  AYTAlVBMB4XDTE4M
+00000120: 4451 780d 0a4d 4445 784d 7a4d 774d 466f  DQx..MDExMzMwMFo
+00000130: 5844 5449 324d 4459 794e 7a45 784d 7a4d  XDTI2MDYyNzExMzM
+00000140: 774d 466f 7767 5930 7846 7a41 5642 674e  wMFowgY0xFzAVBgN
+00000150: 5642 414d 4d44 6b5a 3163 326c 7662 6942  VBAMMDkZ1c2lvbiB
+00000160: 5362 3239 300d 0a49 454e 424d 536b 774a  Sb290..IENBMSkwJ
+00000170: 7759 4a4b 6f5a 4968 7663 4e41 516b 4246  wYJKoZIhvcNAQkBF
+00000180: 6870 3262 3278 765a 486c 7465 584a 6659  hp2b2xvZHlteXJfY
+00000190: 6d46 6959 3268 3161 3042 6c63 4746 744c  mFiY2h1a0BlcGFtL
+000001a0: 6d4e 7662 5445 4e0d 0a4d 4173 4741 3155  mNvbTEN..MAsGA1U
+000001b0: 4543 6777 4552 5642 4254 5445 634d 426f  ECgwERVBBTTEcMBo
+000001c0: 4741 3155 4543 7777 5454 6d39 3264 584d  GA1UECwwTTm92dXM
+000001d0: 6754 334a 6b62 7942 545a 574e 7362 334a  gT3JkbyBTZWNsb3J
+000001e0: 3162 5445 4e4d 4173 470d 0a41 3155 4542  1bTENMAsG..A1UEB
+000001f0: 7777 4553 336c 7064 6a45 4c4d 416b 4741  wwES3lpdjELMAkGA
+00000200: 3155 4542 684d 4356 5545 7767 6745 694d  1UEBhMCVUEwggEiM
+00000210: 4130 4743 5371 4753 4962 3344 5145 4241  A0GCSqGSIb3DQEBA
+00000220: 5155 4141 3449 4244 7741 770d 0a67 6745  QUAA4IBDwAw..ggE
+00000230: 4b41 6f49 4241 5143 2b4b 326f 7732 484f  KAoIBAQC+K2ow2HO
+00000240: 372b 5355 5666 4f71 3574 5474 6d48 6a34  7+SUVfOq5tTtmHj4
+00000250: 4c51 696a 484a 3830 336d 4c6b 3970 6b50  LQijHJ803mLk9pkP
+00000260: 6566 2b47 6c6d 6579 7039 4858 650d 0a6a  ef+Glmeyp9HXe..j
+00000270: 446c 5143 3034 4d65 6f76 4d42 654e 5461  DlQC04MeovMBeNTa
+00000280: 7130 7769 6266 3771 6173 396e 6958 6265  q0wibf7qas9niXbe
+00000290: 5852 567a 6865 5a49 467a 694d 5871 5275  XRVzheZIFziMXqRu
+000002a0: 774c 7163 304b 5864 4478 4944 5054 620d  wLqc0KXdDxIDPTb.
+000002b0: 0a54 5733 4b30 4845 364d 2f65 4174 5466  .TW3K0HE6M/eAtTf
+000002c0: 6e39 2b5a 2f4c 6e6b 5774 347a 4d58 6173  n9+Z/LnkWt4zMXas
+000002d0: 6330 3268 7675 6673 6d49 5645 754e 6263  c02hvufsmIVEuNbc
+000002e0: 3156 6872 734a 4a67 3575 6b38 386c 6450  1VhrsJJg5uk88ldP
+000002f0: 4d0d 0a4c 5346 376e 6666 3965 595a 5448  M..LSF7nff9eYZTH
+00000300: 5967 4379 426b 7439 614c 2b66 776f 584f  YgCyBkt9aL+fwoXO
+00000310: 3665 5344 5341 686a 6f70 5833 6c68 6469  6eSDSAhjopX3lhdi
+00000320: 646b 4d2b 6e69 3745 4f68 6c4e 3753 546d  dkM+ni7EOhlN7STm
+00000330: 6744 4d0d 0a57 4b68 396e 4d6a 5844 3566  gDM..WKh9nMjXD5f
+00000340: 3238 5047 6874 572f 645a 766e 3453 7a61  28PGhtW/dZvn4Sza
+00000350: 7352 4535 4d65 6145 7849 6c42 6d68 6b57  sRE5MeaExIlBmhkW
+00000360: 4555 6756 4379 5037 4c76 7551 4752 5550  EUgVCyP7LvuQGRUP
+00000370: 4b2b 4e59 7a0d 0a46 4532 434c 5275 6972  K+NYz..FE2CLRuir
+00000380: 4c43 5779 3148 4974 396c 4c7a 6950 6a6c  LCWy1HIt9lLziPjl
+00000390: 5a34 3336 316d 4e41 674d 4241 4147 6a59  Z4361mNAgMBAAGjY
+000003a0: 7a42 684d 4230 4741 3155 6444 6751 5742  zBhMB0GA1UdDgQWB
+000003b0: 4252 3053 6868 7a0d 0a4f 754d 3935 4268  BR0Shhz..OuM95Bh
+000003c0: 4430 6d57 7843 316a 2b4b 7245 3655 6a41  D0mWxC1j+KrE6UjA
+000003d0: 4d42 674e 5648 524d 4542 5441 4441 5148  MBgNVHRMEBTADAQH
+000003e0: 2f4d 4173 4741 3155 6444 7751 4541 7749  /MAsGA1UdDwQEAwI
+000003f0: 4242 6a41 6c42 674e 560d 0a48 5245 4548  BBjAlBgNV..HREEH
+00000400: 6a41 6367 5270 3262 3278 765a 486c 7465  jAcgRp2b2xvZHlte
+00000410: 584a 6659 6d46 6959 3268 3161 3042 6c63  XJfYmFiY2h1a0Blc
+00000420: 4746 744c 6d4e 7662 5441 4e42 676b 7168  GFtLmNvbTANBgkqh
+00000430: 6b69 4739 7730 4241 5173 460d 0a41 414f  kiG9w0BAQsF..AAO
+00000440: 4341 5145 416c 3862 7631 4854 5965 336c  CAQEAl8bv1HTYe3l
+00000450: 3459 2b67 3054 565a 5237 6259 4c35 424e  4Y+g0TVZR7bYL5BN
+00000460: 736e 4767 7179 3071 5335 6675 3939 316b  snGgqy0qS5fu991k
+00000470: 6858 5766 2b5a 7761 324d 4c56 6e0d 0a59  hXWf+Zwa2MLVn..Y
+00000480: 616b 4d6e 4c6b 6a76 6448 7155 7057 4d4a  akMnLkjvdHqUpWMJ
+00000490: 2f53 3832 6f32 7a57 476d 6d75 7863 6135  /S82o2zWGmmuxca5
+000004a0: 3665 686a 7843 6950 2f6e 6b6d 344d 3734  6ehjxCiP/nkm4M74
+000004b0: 7958 7a32 5238 6375 3532 5778 596e 460d  yXz2R8cu52WxYnF.
+000004c0: 0a79 4d76 6761 777a 5136 6331 7968 765a  .yMvgawzQ6c1yhvZ
+000004d0: 6976 2f67 4545 374b 6462 5952 564b 4c48  iv/gEE7KdbYRVKLH
+000004e0: 5067 427a 6679 7570 3231 6935 6e67 536c  PgBzfyup21i5ngSl
+000004f0: 5463 4d52 5253 376f 4f42 6d6f 7965 3471  TcMRRS7oOBmoye4q
+00000500: 630d 0a36 6164 7136 4874 5936 582f 4f6e  c..6adq6HtY6X/On
+00000510: 5a39 4935 786f 524e 3147 6376 614c 5567  Z9I5xoRN1GcvaLUg
+00000520: 5545 3669 6754 6956 6131 7046 386b 6564  UE6igTiVa1pF8ked
+00000530: 5768 4859 3777 7a54 5842 787a 5376 495a  WhHY7wzTXBxzSvIZ
+00000540: 6b43 550d 0a56 4845 4f7a 7661 476b 396d  kCU..VHEOzvaGk9m
+00000550: 6950 366e 4272 4466 4e76 376d 496b 6745  iP6nBrDfNv7mIkgE
+00000560: 4b41 5272 6a6a 5370 6d4a 6173 4945 552b  KARrjjSpmJasIEU+
+00000570: 6d4e 747a 654f 4945 694d 7457 3145 4d52  mNtzeOIEiMtW1EMR
+00000580: 6334 3537 6f0d 0a30 5064 4649 336a 7365  c457o..0PdFI3jse
+00000590: 794c 5650 5668 457a 556b 7543 376d 776a  yLVPVhEzUkuC7mwj
+000005a0: 6237 4365 513d 3d0d 0a2d 2d2d 2d2d 454e  b7CeQ==..-----EN
+000005b0: 4420 4345 5254 4946 4943 4154 452d 2d2d  D CERTIFICATE---
+000005c0: 2d2d 0d0a                                --..
```

## aos_keys/files/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-#
-#  Copyright (c) 2018-2022 Renesas Inc.
-#  Copyright (c) 2018-2022 EPAM Systems Inc.
-#
-"""Resources module."""
+#
+#  Copyright (c) 2018-2022 Renesas Inc.
+#  Copyright (c) 2018-2022 EPAM Systems Inc.
+#
+"""Resources module."""
```

## Comparing `aos_keys-1.5.2b3.dist-info/METADATA` & `aos_keys-1.5.2b4.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,11 +1,12 @@
 Metadata-Version: 2.1
 Name: aos-keys
-Version: 1.5.2b3
+Version: 1.5.2b4
 Summary: AosEdge private keys and certificate manager
+Home-page: UNKNOWN
 Author: EPAM Systems
 Author-email: support@aoscloud.io
 License: Apache License 2.0
 Platform: any
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.7
@@ -78,17 +79,19 @@
 aos-keys info -c {path-to-cert} {--oem|--sp|--fleet}
 ```
 >Where: 
 >* **-c** - Path to user certificate
 >* **-sp** - Show info of default Service Provider user
 >* **-oem** - Show info of default OEM user
 >* **-fleet** - Show info of default Fleet Owner user
- 
+
 Example:
 Show info about default SP user certificate
 ```bash
 aos-keys info --sp
 ```
 Show info about default OEM user certificate
 ```bash
 aos-keys info --oem
 ```
+
+
```

