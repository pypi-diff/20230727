# Comparing `tmp/dragonion-0.1.0rc0-py3-none-any.whl.zip` & `tmp/dragonion-0.1.0rc3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,71 +1,71 @@
-Zip file size: 37299 bytes, number of entries: 69
--rw-r--r--  2.0 fat       72 b- defN 80-Jan-01 00:00 dragonion/__init__.py
--rw-r--r--  2.0 fat       72 b- defN 80-Jan-01 00:00 dragonion/__main__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/__init__.py
--rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 dragonion/modules/cli/__init__.py
--rw-r--r--  2.0 fat     1351 b- defN 80-Jan-01 00:00 dragonion/modules/cli/main.py
--rw-r--r--  2.0 fat       22 b- defN 80-Jan-01 00:00 dragonion/modules/tui/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/__init__.py
--rw-r--r--  2.0 fat      682 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/authentication.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/utils/__init__.py
--rw-r--r--  2.0 fat     1687 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/utils/results.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/__init__.py
--rw-r--r--  2.0 fat     3328 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/containers.py
--rw-r--r--  2.0 fat      825 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/inputs.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/__init__.py
--rw-r--r--  2.0 fat      915 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/chat.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/__init__.py
--rw-r--r--  2.0 fat     1231 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/command.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/__init__.py
--rw-r--r--  2.0 fat      590 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/avatar.py
--rw-r--r--  2.0 fat     1523 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/connect.py
--rw-r--r--  2.0 fat      647 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/disconnect.py
--rw-r--r--  2.0 fat     3242 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/help.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/__init__.py
--rw-r--r--  2.0 fat      513 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/socket.py
--rw-r--r--  2.0 fat     1923 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/join.py
--rw-r--r--  2.0 fat      502 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/general.py
--rw-r--r--  2.0 fat      669 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/message.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/__init__.py
--rw-r--r--  2.0 fat      197 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/__init__.py
--rw-r--r--  2.0 fat      557 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/connect.py
--rw-r--r--  2.0 fat      472 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/disconnect.py
--rw-r--r--  2.0 fat      457 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/error.py
--rw-r--r--  2.0 fat      133 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/helpers.py
--rw-r--r--  2.0 fat      913 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/message.py
--rw-r--r--  2.0 fat      473 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/notification.py
--rw-r--r--  2.0 fat     1295 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/task.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/__init__.py
--rw-r--r--  2.0 fat     3599 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/containers.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/inputs/__init__.py
--rw-r--r--  2.0 fat      953 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/inputs/message_input.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/items/__init__.py
--rw-r--r--  2.0 fat     3364 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/items/message.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/helpers/__init__.py
--rw-r--r--  2.0 fat      526 b- defN 80-Jan-01 00:00 dragonion/modules/tui/helpers/storage.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/__init__.py
--rw-r--r--  2.0 fat      715 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/identity.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/utils/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/__init__.py
--rw-r--r--  2.0 fat     1526 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/containers.py
--rw-r--r--  2.0 fat      952 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/inputs.py
--rw-r--r--  2.0 fat     2545 b- defN 80-Jan-01 00:00 dragonion/modules/tui/tui.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/utils/__init__.py
--rw-r--r--  2.0 fat        6 b- defN 80-Jan-01 00:00 dragonion/utils/core/__init__.py
--rw-r--r--  2.0 fat       87 b- defN 80-Jan-01 00:00 dragonion/utils/core/const.py
--rw-r--r--  2.0 fat     2905 b- defN 80-Jan-01 00:00 dragonion/utils/core/dirs.py
--rw-r--r--  2.0 fat      726 b- defN 80-Jan-01 00:00 dragonion/utils/core/emoji.py
--rw-r--r--  2.0 fat       57 b- defN 80-Jan-01 00:00 dragonion/utils/onion/__init__.py
--rw-r--r--  2.0 fat     1140 b- defN 80-Jan-01 00:00 dragonion/utils/onion/auth.py
--rw-r--r--  2.0 fat     7007 b- defN 80-Jan-01 00:00 dragonion/utils/onion/onion.py
--rw-r--r--  2.0 fat    10968 b- defN 80-Jan-01 00:00 dragonion/utils/onion/stem_process.py
--rw-r--r--  2.0 fat     2448 b- defN 80-Jan-01 00:00 dragonion/utils/onion/tor_downloader.py
--rw-r--r--  2.0 fat       44 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc0.dist-info/entry_points.txt
--rw-r--r--  2.0 fat     1631 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc0.dist-info/METADATA
--rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc0.dist-info/WHEEL
-?rw-r--r--  2.0 fat     7267 b- defN 16-Jan-01 00:00 dragonion-0.1.0rc0.dist-info/RECORD
-69 files, 72971 bytes uncompressed, 25053 bytes compressed:  65.7%
+Zip file size: 37006 bytes, number of entries: 69
+-rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 dragonion/__init__.py
+-rw-r--r--  2.0 unx       67 b- defN 80-Jan-01 00:00 dragonion/__main__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 dragonion/modules/cli/__init__.py
+-rw-r--r--  2.0 unx     1315 b- defN 80-Jan-01 00:00 dragonion/modules/cli/main.py
+-rw-r--r--  2.0 unx       21 b- defN 80-Jan-01 00:00 dragonion/modules/tui/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/__init__.py
+-rw-r--r--  2.0 unx      654 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/authentication.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/utils/__init__.py
+-rw-r--r--  2.0 unx     1646 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/utils/results.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/__init__.py
+-rw-r--r--  2.0 unx     3219 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/containers.py
+-rw-r--r--  2.0 unx      789 b- defN 80-Jan-01 00:00 dragonion/modules/tui/authentication/widgets/inputs.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/__init__.py
+-rw-r--r--  2.0 unx      881 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/chat.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/__init__.py
+-rw-r--r--  2.0 unx     1194 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/command.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/__init__.py
+-rw-r--r--  2.0 unx      574 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/avatar.py
+-rw-r--r--  2.0 unx     1475 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/connect.py
+-rw-r--r--  2.0 unx      626 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/disconnect.py
+-rw-r--r--  2.0 unx     3158 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/help.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/__init__.py
+-rw-r--r--  2.0 unx      494 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/socket.py
+-rw-r--r--  2.0 unx     1869 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/command/commands/join.py
+-rw-r--r--  2.0 unx      481 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/general.py
+-rw-r--r--  2.0 unx      649 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/handlers/input/message.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/__init__.py
+-rw-r--r--  2.0 unx      192 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/__init__.py
+-rw-r--r--  2.0 unx      539 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/connect.py
+-rw-r--r--  2.0 unx      457 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/disconnect.py
+-rw-r--r--  2.0 unx      442 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/error.py
+-rw-r--r--  2.0 unx      128 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/helpers.py
+-rw-r--r--  2.0 unx      887 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/message.py
+-rw-r--r--  2.0 unx      458 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/notification.py
+-rw-r--r--  2.0 unx     1251 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/utils/tasks/socket_handler/task.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/__init__.py
+-rw-r--r--  2.0 unx     3519 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/containers.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/inputs/__init__.py
+-rw-r--r--  2.0 unx      915 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/inputs/message_input.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/items/__init__.py
+-rw-r--r--  2.0 unx     3232 b- defN 80-Jan-01 00:00 dragonion/modules/tui/chat/widgets/items/message.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/helpers/__init__.py
+-rw-r--r--  2.0 unx      506 b- defN 80-Jan-01 00:00 dragonion/modules/tui/helpers/storage.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/__init__.py
+-rw-r--r--  2.0 unx      687 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/identity.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/utils/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/__init__.py
+-rw-r--r--  2.0 unx     1473 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/containers.py
+-rw-r--r--  2.0 unx      917 b- defN 80-Jan-01 00:00 dragonion/modules/tui/identity/widgets/inputs.py
+-rw-r--r--  2.0 unx     2467 b- defN 80-Jan-01 00:00 dragonion/modules/tui/tui.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/utils/__init__.py
+-rw-r--r--  2.0 unx        5 b- defN 80-Jan-01 00:00 dragonion/utils/core/__init__.py
+-rw-r--r--  2.0 unx       83 b- defN 80-Jan-01 00:00 dragonion/utils/core/const.py
+-rw-r--r--  2.0 unx     2805 b- defN 80-Jan-01 00:00 dragonion/utils/core/dirs.py
+-rw-r--r--  2.0 unx      699 b- defN 80-Jan-01 00:00 dragonion/utils/core/emoji.py
+-rw-r--r--  2.0 unx       52 b- defN 80-Jan-01 00:00 dragonion/utils/onion/__init__.py
+-rw-r--r--  2.0 unx     1110 b- defN 80-Jan-01 00:00 dragonion/utils/onion/auth.py
+-rw-r--r--  2.0 unx     6796 b- defN 80-Jan-01 00:00 dragonion/utils/onion/onion.py
+-rw-r--r--  2.0 unx    10968 b- defN 80-Jan-01 00:00 dragonion/utils/onion/stem_process.py
+-rw-r--r--  2.0 unx     2365 b- defN 80-Jan-01 00:00 dragonion/utils/onion/tor_downloader.py
+-rw-r--r--  2.0 unx     1631 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc3.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       44 b- defN 80-Jan-01 00:00 dragonion-0.1.0rc3.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     7267 b- defN 16-Jan-01 00:00 dragonion-0.1.0rc3.dist-info/RECORD
+69 files, 71267 bytes uncompressed, 24760 bytes compressed:  65.3%
```

## zipnote {}

```diff
@@ -189,20 +189,20 @@
 
 Filename: dragonion/utils/onion/stem_process.py
 Comment: 
 
 Filename: dragonion/utils/onion/tor_downloader.py
 Comment: 
 
-Filename: dragonion-0.1.0rc0.dist-info/entry_points.txt
+Filename: dragonion-0.1.0rc3.dist-info/METADATA
 Comment: 
 
-Filename: dragonion-0.1.0rc0.dist-info/METADATA
+Filename: dragonion-0.1.0rc3.dist-info/WHEEL
 Comment: 
 
-Filename: dragonion-0.1.0rc0.dist-info/WHEEL
+Filename: dragonion-0.1.0rc3.dist-info/entry_points.txt
 Comment: 
 
-Filename: dragonion-0.1.0rc0.dist-info/RECORD
+Filename: dragonion-0.1.0rc3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dragonion/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from dragonion.modules.cli.main import cli
-
-
-def main():
-    cli()
+from dragonion.modules.cli.main import cli
+
+
+def main():
+    cli()
```

## dragonion/__main__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from dragonion import main
-
-
-if __name__ == '__main__':
-    main()
+from dragonion import main
+
+
+if __name__ == '__main__':
+    main()
```

## dragonion/modules/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/cli/main.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-import click
-
-import os
-
-from ..tui import app
-
-
-def validate_username(_: click.Context, __: click.Parameter, value: str | None):
-    if value is not None and not (4 <= len(value) <= 14):
-        raise click.BadParameter("Username length must be from 4 to 14 symbols")
-    else:
-        return value
-
-
-@click.command()
-@click.option('--auth', '-a', required=False, type=str,
-              help='Service name (.auth file with this name should exist in workdir)')
-@click.option('--username', '-u', required=False, type=str,
-              help='Set username', callback=validate_username)
-@click.option('--connect', '-c', required=False, is_flag=True,
-              help='Will connect to tor automatically')
-@click.option('--dev-proxy-port', required=False, type=int,
-              help='Won\'t start own tor, will try to connect to specified')
-def cli(auth: str | None, username: str | None, connect: bool,
-        dev_proxy_port: int | None):
-    if auth is not None and os.path.isfile(f'{auth}.auth'):
-        from ..tui.authentication.utils.results import ServiceAuthResult
-        app._pre_service_auth = ServiceAuthResult(f'{auth}.auth')
-
-    if username is not None:
-        app._pre_username = username
-
-    app.user_storage.connect = connect
-    app.user_storage.dev_proxy_port = dev_proxy_port
-
-    app.run()
+import click
+
+import os
+
+from ..tui import app
+
+
+def validate_username(_: click.Context, __: click.Parameter, value: str | None):
+    if value is not None and not (4 <= len(value) <= 14):
+        raise click.BadParameter("Username length must be from 4 to 14 symbols")
+    else:
+        return value
+
+
+@click.command()
+@click.option('--auth', '-a', required=False, type=str,
+              help='Service name (.auth file with this name should exist in workdir)')
+@click.option('--username', '-u', required=False, type=str,
+              help='Set username', callback=validate_username)
+@click.option('--connect', '-c', required=False, is_flag=True,
+              help='Will connect to tor automatically')
+@click.option('--dev-proxy-port', required=False, type=int,
+              help='Won\'t start own tor, will try to connect to specified')
+def cli(auth: str | None, username: str | None, connect: bool,
+        dev_proxy_port: int | None):
+    if auth is not None and os.path.isfile(f'{auth}.auth'):
+        from ..tui.authentication.utils.results import ServiceAuthResult
+        app._pre_service_auth = ServiceAuthResult(f'{auth}.auth')
+
+    if username is not None:
+        app._pre_username = username
+
+    app.user_storage.connect = connect
+    app.user_storage.dev_proxy_port = dev_proxy_port
+
+    app.run()
```

## dragonion/modules/tui/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-from .tui import app
+from .tui import app
```

## dragonion/modules/tui/authentication/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/authentication/authentication.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-from textual.app import ComposeResult
-from textual.widgets import Static
-from textual.containers import Center
-from .widgets.containers import LoginContainer
-
-
-class LoginWidget(Static):
-    DEFAULT_CSS = """
-    LoginWidget {
-        height: 100%;
-        layout: vertical;
-        align-vertical: middle;
-    }
-
-    LoginContainer {
-        align: center middle; 
-        height: 1fr;
-        max-width: 50%;
-    }
-    """
-
-    def _on_compose(self) -> None:
-        from .. import app
-        # noinspection PyTypeChecker
-        app.title = 'dragonion - authentication'
-
-    def compose(self) -> ComposeResult:
-        yield Center(LoginContainer())
+from textual.app import ComposeResult
+from textual.widgets import Static
+from textual.containers import Center
+from .widgets.containers import LoginContainer
+
+
+class LoginWidget(Static):
+    DEFAULT_CSS = """
+    LoginWidget {
+        height: 100%;
+        layout: vertical;
+        align-vertical: middle;
+    }
+
+    LoginContainer {
+        align: center middle; 
+        height: 1fr;
+        max-width: 50%;
+    }
+    """
+
+    def _on_compose(self) -> None:
+        from .. import app
+        # noinspection PyTypeChecker
+        app.title = 'dragonion - authentication'
+
+    def compose(self) -> ComposeResult:
+        yield Center(LoginContainer())
```

## dragonion/modules/tui/authentication/utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/authentication/utils/results.py

 * *Ordering differences only*

```diff
@@ -1,41 +1,41 @@
-from dataclasses import dataclass
-from typing import Optional
-
-
-@dataclass
-class ServiceAuthResult:
-    service_auth_file: Optional[str] = None
-    raw_auth_strings: Optional[tuple[str, str]] = None
-
-    def __post_init__(self):
-        """
-        Validate service auth result, one of parameters must be valid and other must be
-        None
-        :return:
-        """
-        self.raw_auth_strings = None if self.raw_auth_strings == ('', '') \
-            else self.raw_auth_strings
-        _is_auth_string = self.raw_auth_strings is not None and not \
-            self.raw_auth_strings == ('', '')
-
-        if self.service_auth_file is None and not _is_auth_string:
-            raise ValueError("Exactly one argument should have a value")
-        elif self.service_auth_file is not None and _is_auth_string:
-            raise ValueError("Only one argument should have a value")
-
-        if self.service_auth_file and not self.service_auth_file.endswith('.auth'):
-            raise ValueError("Service auth file should end with .auth")
-
-        # noinspection PyUnresolvedReferences
-        if _is_auth_string and \
-                (len(self.raw_auth_strings[0]) != 56 or
-                 not all(c.isdigit() or c.islower()
-                         for c in self.raw_auth_strings[0])):
-            raise ValueError("Incorrect service id")
-
-        # noinspection PyUnresolvedReferences
-        if _is_auth_string and \
-                (len(self.raw_auth_strings[1]) != 52 or
-                 not all(c.isdigit() or c.isupper()
-                         for c in self.raw_auth_strings[1])):
-            raise ValueError("Incorrect auth string")
+from dataclasses import dataclass
+from typing import Optional
+
+
+@dataclass
+class ServiceAuthResult:
+    service_auth_file: Optional[str] = None
+    raw_auth_strings: Optional[tuple[str, str]] = None
+
+    def __post_init__(self):
+        """
+        Validate service auth result, one of parameters must be valid and other must be
+        None
+        :return:
+        """
+        self.raw_auth_strings = None if self.raw_auth_strings == ('', '') \
+            else self.raw_auth_strings
+        _is_auth_string = self.raw_auth_strings is not None and not \
+            self.raw_auth_strings == ('', '')
+
+        if self.service_auth_file is None and not _is_auth_string:
+            raise ValueError("Exactly one argument should have a value")
+        elif self.service_auth_file is not None and _is_auth_string:
+            raise ValueError("Only one argument should have a value")
+
+        if self.service_auth_file and not self.service_auth_file.endswith('.auth'):
+            raise ValueError("Service auth file should end with .auth")
+
+        # noinspection PyUnresolvedReferences
+        if _is_auth_string and \
+                (len(self.raw_auth_strings[0]) != 56 or
+                 not all(c.isdigit() or c.islower()
+                         for c in self.raw_auth_strings[0])):
+            raise ValueError("Incorrect service id")
+
+        # noinspection PyUnresolvedReferences
+        if _is_auth_string and \
+                (len(self.raw_auth_strings[1]) != 52 or
+                 not all(c.isdigit() or c.isupper()
+                         for c in self.raw_auth_strings[1])):
+            raise ValueError("Incorrect auth string")
```

## dragonion/modules/tui/authentication/widgets/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/authentication/widgets/containers.py

 * *Ordering differences only*

```diff
@@ -1,109 +1,109 @@
-from ..utils.results import ServiceAuthResult
-
-from textual import on
-from textual.app import ComposeResult
-from .inputs import AuthFileSelect, RawStringsAuthLayout
-
-from textual.widgets import (
-    Static,
-    Label,
-    Input,
-    Select,
-    Button
-)
-from textual.containers import Center
-
-
-class AuthVariants(Static):
-    DEFAULT_CSS = """
-    .margin-1 {
-        margin: 1;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        yield AuthFileSelect()
-        yield Center(Label('OR', classes='margin-1'))
-        yield RawStringsAuthLayout()
-
-    @on(Input.Changed)
-    def on_input_changed(self):
-        """
-        Disable and enable file select on raw strings input changed
-        :return:
-        """
-        if self.query_one('#login_auth_string_input', expect_type=Input).value \
-                or self. \
-                query_one("#login_service_id_input", expect_type=Input).value:
-            self.query_one(AuthFileSelect).disabled = True
-        else:
-            self.query_one(AuthFileSelect).disabled = False
-
-    @on(Select.Changed)
-    def on_select_changed(self, event: Select.Changed):
-        """
-        Disable and enable raw strings on file input changed
-        :param event: Event passed by decorator
-        :return:
-        """
-        if event.value:
-            self.query_one(
-                '#login_auth_string_input',
-                expect_type=Input
-            ).disabled = True
-            self.query_one(
-                '#login_service_id_input',
-                expect_type=Input
-            ).disabled = True
-        else:
-            self.query_one(
-                '#login_auth_string_input',
-                expect_type=Input
-            ).disabled = False
-            self.query_one(
-                '#login_service_id_input',
-                expect_type=Input
-            ).disabled = False
-
-
-class LoginContainer(Static):
-    DEFAULT_CSS = """
-    #login_authenticate_button {
-        margin-top: 1;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        yield Center(AuthVariants())
-        yield Center(Button(
-            label='Authenticate',
-            name='authenticate_button',
-            variant='success',
-            id='login_authenticate_button'
-        ))
-
-    @on(Button.Pressed, "#login_authenticate_button")
-    def on_auth_button_pressed(self, _: Button.Pressed):
-        """
-        On auth button press
-        :param _:
-        :return: Modifies global app.service_auth to service auth result where one of
-                 params is None, and other has validated value
-        """
-        try:
-            from ... import app
-            app.service_auth = ServiceAuthResult(
-                raw_auth_strings=(
-                    (_service_id := self.query_one(
-                        '#login_service_id_input',
-                        expect_type=Input).value),
-                    (_auth_string := self.query_one(
-                        '#login_auth_string_input',
-                        expect_type=Input).value)
-                ),
-                service_auth_file=self.query_one(Select).value
-            )
-        except Exception as e:
-            assert e
-            from ... import app
-            app.bell()
+from ..utils.results import ServiceAuthResult
+
+from textual import on
+from textual.app import ComposeResult
+from .inputs import AuthFileSelect, RawStringsAuthLayout
+
+from textual.widgets import (
+    Static,
+    Label,
+    Input,
+    Select,
+    Button
+)
+from textual.containers import Center
+
+
+class AuthVariants(Static):
+    DEFAULT_CSS = """
+    .margin-1 {
+        margin: 1;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        yield AuthFileSelect()
+        yield Center(Label('OR', classes='margin-1'))
+        yield RawStringsAuthLayout()
+
+    @on(Input.Changed)
+    def on_input_changed(self):
+        """
+        Disable and enable file select on raw strings input changed
+        :return:
+        """
+        if self.query_one('#login_auth_string_input', expect_type=Input).value \
+                or self. \
+                query_one("#login_service_id_input", expect_type=Input).value:
+            self.query_one(AuthFileSelect).disabled = True
+        else:
+            self.query_one(AuthFileSelect).disabled = False
+
+    @on(Select.Changed)
+    def on_select_changed(self, event: Select.Changed):
+        """
+        Disable and enable raw strings on file input changed
+        :param event: Event passed by decorator
+        :return:
+        """
+        if event.value:
+            self.query_one(
+                '#login_auth_string_input',
+                expect_type=Input
+            ).disabled = True
+            self.query_one(
+                '#login_service_id_input',
+                expect_type=Input
+            ).disabled = True
+        else:
+            self.query_one(
+                '#login_auth_string_input',
+                expect_type=Input
+            ).disabled = False
+            self.query_one(
+                '#login_service_id_input',
+                expect_type=Input
+            ).disabled = False
+
+
+class LoginContainer(Static):
+    DEFAULT_CSS = """
+    #login_authenticate_button {
+        margin-top: 1;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        yield Center(AuthVariants())
+        yield Center(Button(
+            label='Authenticate',
+            name='authenticate_button',
+            variant='success',
+            id='login_authenticate_button'
+        ))
+
+    @on(Button.Pressed, "#login_authenticate_button")
+    def on_auth_button_pressed(self, _: Button.Pressed):
+        """
+        On auth button press
+        :param _:
+        :return: Modifies global app.service_auth to service auth result where one of
+                 params is None, and other has validated value
+        """
+        try:
+            from ... import app
+            app.service_auth = ServiceAuthResult(
+                raw_auth_strings=(
+                    (_service_id := self.query_one(
+                        '#login_service_id_input',
+                        expect_type=Input).value),
+                    (_auth_string := self.query_one(
+                        '#login_auth_string_input',
+                        expect_type=Input).value)
+                ),
+                service_auth_file=self.query_one(Select).value
+            )
+        except Exception as e:
+            assert e
+            from ... import app
+            app.bell()
```

## dragonion/modules/tui/authentication/widgets/inputs.py

 * *Ordering differences only*

```diff
@@ -1,36 +1,36 @@
-from textual.app import ComposeResult
-from textual.widgets import (
-    Static,
-    Select,
-    Input
-)
-
-import os
-
-
-class AuthFileSelect(Static):
-    def compose(self) -> ComposeResult:
-        yield Select(
-            ((file, file) for file in os.listdir() if file.endswith('.auth')),
-            prompt='Service .auth file',
-            id='auth_file_select'
-        )
-
-
-class RawStringsAuthLayout(Static):
-    DEFAULT_CSS = """
-    #login_auth_string_input {
-        margin-top: 1;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        yield Input(
-            placeholder='service id',
-            id='login_service_id_input'
-        )
-        yield Input(
-            placeholder='AUTH STRING',
-            id='login_auth_string_input',
-            password=True
-        )
+from textual.app import ComposeResult
+from textual.widgets import (
+    Static,
+    Select,
+    Input
+)
+
+import os
+
+
+class AuthFileSelect(Static):
+    def compose(self) -> ComposeResult:
+        yield Select(
+            ((file, file) for file in os.listdir() if file.endswith('.auth')),
+            prompt='Service .auth file',
+            id='auth_file_select'
+        )
+
+
+class RawStringsAuthLayout(Static):
+    DEFAULT_CSS = """
+    #login_auth_string_input {
+        margin-top: 1;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        yield Input(
+            placeholder='service id',
+            id='login_service_id_input'
+        )
+        yield Input(
+            placeholder='AUTH STRING',
+            id='login_auth_string_input',
+            password=True
+        )
```

## dragonion/modules/tui/chat/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/chat.py

 * *Ordering differences only*

```diff
@@ -1,34 +1,34 @@
-from textual.app import ComposeResult
-from textual.widgets import Static
-from .widgets.containers import MessagesContainer
-from .widgets.inputs.message_input import InputContainer
-
-from ..authentication.utils.results import ServiceAuthResult
-from dragonion_core.proto.encryption.identity import Identity
-
-
-class ChatWidget(Static):
-    DEFAULT_CSS = """
-    .input {
-        dock: bottom;
-        height: 3;
-    }
-    """
-
-    def __init__(
-            self,
-            service_auth: ServiceAuthResult,
-            identity: Identity
-    ):
-        self.service_auth = service_auth
-        self.identity = identity
-        super().__init__()
-
-    def _on_compose(self) -> None:
-        from .. import app
-        # noinspection PyTypeChecker
-        app.title = 'dragonion'
-
-    def compose(self) -> ComposeResult:
-        yield MessagesContainer()
-        yield InputContainer()
+from textual.app import ComposeResult
+from textual.widgets import Static
+from .widgets.containers import MessagesContainer
+from .widgets.inputs.message_input import InputContainer
+
+from ..authentication.utils.results import ServiceAuthResult
+from dragonion_core.proto.encryption.identity import Identity
+
+
+class ChatWidget(Static):
+    DEFAULT_CSS = """
+    .input {
+        dock: bottom;
+        height: 3;
+    }
+    """
+
+    def __init__(
+            self,
+            service_auth: ServiceAuthResult,
+            identity: Identity
+    ):
+        self.service_auth = service_auth
+        self.identity = identity
+        super().__init__()
+
+    def _on_compose(self) -> None:
+        from .. import app
+        # noinspection PyTypeChecker
+        app.title = 'dragonion'
+
+    def compose(self) -> ComposeResult:
+        yield MessagesContainer()
+        yield InputContainer()
```

## dragonion/modules/tui/chat/utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/input/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/input/command/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/input/command/command.py

 * *Ordering differences only*

```diff
@@ -1,37 +1,37 @@
-from .commands.join import join_command
-from .commands.connect import connect_command
-from .commands.disconnect import disconnect_command
-from .commands.help import help_command
-from .commands.avatar import avatar_command
-
-from textual.widgets import Static
-
-
-async def not_found_command(_: list):
-    from dragonion.modules.tui import app
-
-    app.query_one('MessagesContainer').write(
-        "[red]Command not found[/], use /help to get list of available commands"
-    )
-
-
-async def handle_command(full_text: str):
-    command, args = (full_text.partition(' ')[0], full_text.partition(' ')[2].split())
-
-    try:
-        result = await ({
-            '/help': help_command,
-            '/join': join_command,
-            '/connect': connect_command,
-            '/disconnect': disconnect_command,
-            '/avatar': avatar_command
-        }.get(command, not_found_command)(args))
-    except Exception as e:
-        result = f'{e.__class__}: {e}'
-
-    if result is not None:
-        from dragonion.modules.tui import app
-        app.query_one('MessagesContainer').mount_scroll(Static(
-            f"[red]Error[/] happened while executing {command}: "
-            f"{result} \n"
-        ))
+from .commands.join import join_command
+from .commands.connect import connect_command
+from .commands.disconnect import disconnect_command
+from .commands.help import help_command
+from .commands.avatar import avatar_command
+
+from textual.widgets import Static
+
+
+async def not_found_command(_: list):
+    from dragonion.modules.tui import app
+
+    app.query_one('MessagesContainer').write(
+        "[red]Command not found[/], use /help to get list of available commands"
+    )
+
+
+async def handle_command(full_text: str):
+    command, args = (full_text.partition(' ')[0], full_text.partition(' ')[2].split())
+
+    try:
+        result = await ({
+            '/help': help_command,
+            '/join': join_command,
+            '/connect': connect_command,
+            '/disconnect': disconnect_command,
+            '/avatar': avatar_command
+        }.get(command, not_found_command)(args))
+    except Exception as e:
+        result = f'{e.__class__}: {e}'
+
+    if result is not None:
+        from dragonion.modules.tui import app
+        app.query_one('MessagesContainer').mount_scroll(Static(
+            f"[red]Error[/] happened while executing {command}: "
+            f"{result} \n"
+        ))
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/avatar.py

 * *Ordering differences only*

```diff
@@ -1,16 +1,16 @@
-from dragonion.utils.core.emoji import random_emoji
-
-
-async def avatar_command(command_args: list):
-    from dragonion.modules.tui import app
-    container = app.query_one('MessagesContainer')
-    if not command_args:
-        app.user_storage.avatar = random_emoji()
-        container.write(f'Random emoji set: {app.user_storage.avatar}')
-        return
-
-    if len(command_args[0]) != 1:
-        return 'avatar length must be exactly 1 symbol'
-    else:
-        app.user_storage.avatar = command_args[0]
-        container.write(f'Avatar set to: {app.user_storage.avatar}')
+from dragonion.utils.core.emoji import random_emoji
+
+
+async def avatar_command(command_args: list):
+    from dragonion.modules.tui import app
+    container = app.query_one('MessagesContainer')
+    if not command_args:
+        app.user_storage.avatar = random_emoji()
+        container.write(f'Random emoji set: {app.user_storage.avatar}')
+        return
+
+    if len(command_args[0]) != 1:
+        return 'avatar length must be exactly 1 symbol'
+    else:
+        app.user_storage.avatar = command_args[0]
+        container.write(f'Avatar set to: {app.user_storage.avatar}')
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/connect.py

 * *Ordering differences only*

```diff
@@ -1,48 +1,48 @@
-from textual.widgets import Static
-
-from dragonion.utils.onion import Onion
-from dragonion.utils.onion.auth import create_service_auth
-
-from .helpers import socket
-
-
-async def connect_command(command_args: list):
-    if command_args:
-        return 'this command doesn\'t accepts any arguments'
-
-    from dragonion.modules.tui import app
-
-    container = app.query_one('MessagesContainer')
-
-    if app.user_storage.onion:
-        container.mount(
-            Static('Cleaning up existing onion...\n', classes='onion_setup_logs')
-        )
-        app.user_storage.onion.cleanup()
-        app.user_storage.onion = None
-
-    app.user_storage.onion = Onion()
-    app.user_storage.host = create_service_auth(
-        app.user_storage.onion.tor_data_directory_name,
-        service_name=app.service_auth.service_auth_file,
-        auth_strings=app.service_auth.raw_auth_strings
-    )
-
-    if not app.user_storage.dev_proxy_port:
-        await app.user_storage.onion.connect(
-            init_msg_handler=lambda x: container.mount_scroll(
-                Static(str(x), classes='onion_setup_logs')
-            )
-        )
-
-    container.mount_scroll(
-        Static(
-            'Connecting socket...',
-            classes='onion_setup_logs'
-        )
-    )
-    socket.connect()
-
-    container.mount_scroll(Static(f'[green]Connected[/] to onion and authenticated '
-                                  f'on {app.user_storage.host}'))
-    container.query('.onion_setup_logs').remove()
+from textual.widgets import Static
+
+from dragonion.utils.onion import Onion
+from dragonion.utils.onion.auth import create_service_auth
+
+from .helpers import socket
+
+
+async def connect_command(command_args: list):
+    if command_args:
+        return 'this command doesn\'t accepts any arguments'
+
+    from dragonion.modules.tui import app
+
+    container = app.query_one('MessagesContainer')
+
+    if app.user_storage.onion:
+        container.mount(
+            Static('Cleaning up existing onion...\n', classes='onion_setup_logs')
+        )
+        app.user_storage.onion.cleanup()
+        app.user_storage.onion = None
+
+    app.user_storage.onion = Onion()
+    app.user_storage.host = create_service_auth(
+        app.user_storage.onion.tor_data_directory_name,
+        service_name=app.service_auth.service_auth_file,
+        auth_strings=app.service_auth.raw_auth_strings
+    )
+
+    if not app.user_storage.dev_proxy_port:
+        await app.user_storage.onion.connect(
+            init_msg_handler=lambda x: container.mount_scroll(
+                Static(str(x), classes='onion_setup_logs')
+            )
+        )
+
+    container.mount_scroll(
+        Static(
+            'Connecting socket...',
+            classes='onion_setup_logs'
+        )
+    )
+    socket.connect()
+
+    container.mount_scroll(Static(f'[green]Connected[/] to onion and authenticated '
+                                  f'on {app.user_storage.host}'))
+    container.query('.onion_setup_logs').remove()
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/disconnect.py

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-from textual.widgets import Static
-
-
-async def disconnect_command(command_args: list):
-    if command_args:
-        return 'this command doesn\'t accepts any arguments'
-
-    from dragonion.modules.tui import app
-
-    container = app.query_one('MessagesContainer')
-
-    if app.user_storage.websocket:
-        container.write('[green]Disconnecting from room...[/]')
-        await app.user_storage.websocket.close()
-        await app.user_storage.websocket.wait_closed()
-        app.user_storage.sock.close()
-
-    if onion := app.user_storage.onion:
-        onion.cleanup()
-
-    container.mount_scroll(Static("Disconnected \n"))
+from textual.widgets import Static
+
+
+async def disconnect_command(command_args: list):
+    if command_args:
+        return 'this command doesn\'t accepts any arguments'
+
+    from dragonion.modules.tui import app
+
+    container = app.query_one('MessagesContainer')
+
+    if app.user_storage.websocket:
+        container.write('[green]Disconnecting from room...[/]')
+        await app.user_storage.websocket.close()
+        await app.user_storage.websocket.wait_closed()
+        app.user_storage.sock.close()
+
+    if onion := app.user_storage.onion:
+        onion.cleanup()
+
+    container.mount_scroll(Static("Disconnected \n"))
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/help.py

 * *Ordering differences only*

```diff
@@ -1,84 +1,84 @@
-from dataclasses import dataclass
-from textual.widgets import Static
-
-
-@dataclass
-class CommandHelp:
-    short_description: str
-    args_description: dict | None
-    long_description: str
-
-
-async def help_command(command_args: list):
-    from dragonion.modules.tui import app
-
-    container = app.query_one('MessagesContainer')
-
-    commands = {
-        'help': CommandHelp(
-            short_description='Get help',
-            args_description={
-                'command': 'Command name to get info about'
-            },
-            long_description='Show this message or pass name of any existing command '
-                             'to get info about it'
-        ),
-        'join': CommandHelp(
-            short_description='Join room',
-            args_description={
-                'name': 'Name of room to join',
-                'password': 'Room password, combination of same room name and password '
-                            'will unite two or more users in one room. Entering '
-                            'password, that is different from other room members '
-                            'will lead you to connecting to ANOTHER room!'
-            },
-            long_description='Join room, pass room name to join with default password '
-                             'or pass room name and password split with space to join '
-                             'password-locked room.'
-        ),
-        'connect': CommandHelp(
-            short_description='Connect to network',
-            long_description='Start tor service and connect to it',
-            args_description=None
-        ),
-        'disconnect': CommandHelp(
-            short_description='Disconnect from room',
-            long_description='Will disconnect you from room and close current '
-                             'onion network connection, you need to rejoin room to'
-                             'continue using chat',
-            args_description=None
-        ),
-        'avatar': CommandHelp(
-            short_description='Set avatar',
-            long_description='Will generate random avatar if no symbol specified '
-                             'or will set your avatar to specified symbol',
-            args_description={
-                'symbol': 'Must be exactly 1 character or not specified, avatar will '
-                          'be set to this character.'
-            }
-        )
-    }
-
-    if command_args:
-        help_ = commands.get(command_args[0])
-        if help_ is None:
-            return f'command {command_args[0]} doesn\'t exist'
-        container.write(
-            f'[green]/{command_args[0]}[/] command: '
-        )
-        container.write(
-            help_.long_description
-        )
-        if help_.args_description is None:
-            return
-        container.write('[gray]Arguments:[/] ')
-        for arg in help_.args_description.keys():
-            container.mount_scroll(Static(
-                f'[italic]{arg}[/]\t{help_.args_description[arg]}'
-            ))
-
-    else:
-        for cmd in commands.keys():
-            container.mount_scroll(Static(
-                f'/{cmd}\t{commands[cmd].short_description}'
-            ))
+from dataclasses import dataclass
+from textual.widgets import Static
+
+
+@dataclass
+class CommandHelp:
+    short_description: str
+    args_description: dict | None
+    long_description: str
+
+
+async def help_command(command_args: list):
+    from dragonion.modules.tui import app
+
+    container = app.query_one('MessagesContainer')
+
+    commands = {
+        'help': CommandHelp(
+            short_description='Get help',
+            args_description={
+                'command': 'Command name to get info about'
+            },
+            long_description='Show this message or pass name of any existing command '
+                             'to get info about it'
+        ),
+        'join': CommandHelp(
+            short_description='Join room',
+            args_description={
+                'name': 'Name of room to join',
+                'password': 'Room password, combination of same room name and password '
+                            'will unite two or more users in one room. Entering '
+                            'password, that is different from other room members '
+                            'will lead you to connecting to ANOTHER room!'
+            },
+            long_description='Join room, pass room name to join with default password '
+                             'or pass room name and password split with space to join '
+                             'password-locked room.'
+        ),
+        'connect': CommandHelp(
+            short_description='Connect to network',
+            long_description='Start tor service and connect to it',
+            args_description=None
+        ),
+        'disconnect': CommandHelp(
+            short_description='Disconnect from room',
+            long_description='Will disconnect you from room and close current '
+                             'onion network connection, you need to rejoin room to'
+                             'continue using chat',
+            args_description=None
+        ),
+        'avatar': CommandHelp(
+            short_description='Set avatar',
+            long_description='Will generate random avatar if no symbol specified '
+                             'or will set your avatar to specified symbol',
+            args_description={
+                'symbol': 'Must be exactly 1 character or not specified, avatar will '
+                          'be set to this character.'
+            }
+        )
+    }
+
+    if command_args:
+        help_ = commands.get(command_args[0])
+        if help_ is None:
+            return f'command {command_args[0]} doesn\'t exist'
+        container.write(
+            f'[green]/{command_args[0]}[/] command: '
+        )
+        container.write(
+            help_.long_description
+        )
+        if help_.args_description is None:
+            return
+        container.write('[gray]Arguments:[/] ')
+        for arg in help_.args_description.keys():
+            container.mount_scroll(Static(
+                f'[italic]{arg}[/]\t{help_.args_description[arg]}'
+            ))
+
+    else:
+        for cmd in commands.keys():
+            container.mount_scroll(Static(
+                f'/{cmd}\t{commands[cmd].short_description}'
+            ))
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/helpers/socket.py

 * *Ordering differences only*

```diff
@@ -1,19 +1,19 @@
-import socks
-
-
-def connect():
-    from dragonion.modules.tui import app
-
-    app.user_storage.sock = socks.socksocket()
-    if not app.user_storage.dev_proxy_port:
-        app.user_storage.sock.setproxy(
-            socks.SOCKS5, *app.user_storage.onion.get_tor_socks_port()
-        )
-    else:
-        app.user_storage.sock.setproxy(
-            socks.SOCKS5, '127.0.0.1', app.user_storage.dev_proxy_port
-        )
-
-    app.user_storage.sock.connect(
-        (app.user_storage.host, 80)
-    )
+import socks
+
+
+def connect():
+    from dragonion.modules.tui import app
+
+    app.user_storage.sock = socks.socksocket()
+    if not app.user_storage.dev_proxy_port:
+        app.user_storage.sock.setproxy(
+            socks.SOCKS5, *app.user_storage.onion.get_tor_socks_port()
+        )
+    else:
+        app.user_storage.sock.setproxy(
+            socks.SOCKS5, '127.0.0.1', app.user_storage.dev_proxy_port
+        )
+
+    app.user_storage.sock.connect(
+        (app.user_storage.host, 80)
+    )
```

## dragonion/modules/tui/chat/utils/handlers/input/command/commands/join.py

 * *Ordering differences only*

```diff
@@ -1,54 +1,54 @@
-import asyncio
-import websockets.client
-from dragonion.modules.tui.chat.utils.tasks.socket_handler.task import handle_websocket
-
-from dragonion_core.proto.web.webmessage import WebConnectionMessage, WebMessage
-
-
-async def join_command(command_args: list):
-    command_args.append("None")
-    if command_args[0] == "None":
-        return "you need to specify room name"
-
-    from dragonion.modules.tui import app
-
-    log = app.query_one('MessagesContainer')
-
-    if not app.user_storage.sock:
-        log.write('[red]Error[/]: run /connect command first')
-        return
-
-    if app.user_storage.websocket:
-        log.write('[green]Disconnecting from room...[/]')
-        await app.user_storage.websocket.close()
-        await app.user_storage.websocket.wait_closed()
-        app.user_storage.sock.close()
-        from .helpers import socket
-        socket.connect()
-
-    log.write(f'[green]Connecting to {command_args[0]}...')
-    app.user_storage.websocket = await websockets.client.connect(
-        f'ws://{app.user_storage.host}:80/{command_args[0]}',
-        sock=app.user_storage.sock
-    )
-    await app.user_storage.websocket.send(
-        WebConnectionMessage(
-            username=app.identity.username,
-            public_key=app.identity.public_key(),
-            password=command_args[1]
-        ).to_json()
-    )
-
-    connection_message = WebMessage.from_json(await app.user_storage.websocket.recv())
-
-    if connection_message.type == "error":
-        log.write(
-            f'[red]Error connecting to room[/]: {connection_message.error_message}'
-        )
-    elif connection_message.type == "connect_answer":
-        app.user_storage.keys |= connection_message.connected_users
-        asyncio.create_task(handle_websocket())
-    else:
-        log.write(
-            f'Received unknown answer {connection_message.type}: {connection_message}'
-        )
+import asyncio
+import websockets.client
+from dragonion.modules.tui.chat.utils.tasks.socket_handler.task import handle_websocket
+
+from dragonion_core.proto.web.webmessage import WebConnectionMessage, WebMessage
+
+
+async def join_command(command_args: list):
+    command_args.append("None")
+    if command_args[0] == "None":
+        return "you need to specify room name"
+
+    from dragonion.modules.tui import app
+
+    log = app.query_one('MessagesContainer')
+
+    if not app.user_storage.sock:
+        log.write('[red]Error[/]: run /connect command first')
+        return
+
+    if app.user_storage.websocket:
+        log.write('[green]Disconnecting from room...[/]')
+        await app.user_storage.websocket.close()
+        await app.user_storage.websocket.wait_closed()
+        app.user_storage.sock.close()
+        from .helpers import socket
+        socket.connect()
+
+    log.write(f'[green]Connecting to {command_args[0]}...')
+    app.user_storage.websocket = await websockets.client.connect(
+        f'ws://{app.user_storage.host}:80/{command_args[0]}',
+        sock=app.user_storage.sock
+    )
+    await app.user_storage.websocket.send(
+        WebConnectionMessage(
+            username=app.identity.username,
+            public_key=app.identity.public_key(),
+            password=command_args[1]
+        ).to_json()
+    )
+
+    connection_message = WebMessage.from_json(await app.user_storage.websocket.recv())
+
+    if connection_message.type == "error":
+        log.write(
+            f'[red]Error connecting to room[/]: {connection_message.error_message}'
+        )
+    elif connection_message.type == "connect_answer":
+        app.user_storage.keys |= connection_message.connected_users
+        asyncio.create_task(handle_websocket())
+    else:
+        log.write(
+            f'Received unknown answer {connection_message.type}: {connection_message}'
+        )
```

## dragonion/modules/tui/chat/utils/handlers/input/general.py

 * *Ordering differences only*

```diff
@@ -1,21 +1,21 @@
-from textual.widgets import Input
-
-from .command.command import handle_command
-from .message import handle_message
-
-
-async def handle_input_submit():
-    from dragonion.modules.tui import app
-    field = app.query_one(
-        "#chat_input_field",
-        expect_type=Input
-    )
-    message = field.value
-    if len(message) == 0:
-        return
-    field.value = ""
-
-    if message[0] == '/':
-        await handle_command(message)
-    else:
-        await handle_message(message)
+from textual.widgets import Input
+
+from .command.command import handle_command
+from .message import handle_message
+
+
+async def handle_input_submit():
+    from dragonion.modules.tui import app
+    field = app.query_one(
+        "#chat_input_field",
+        expect_type=Input
+    )
+    message = field.value
+    if len(message) == 0:
+        return
+    field.value = ""
+
+    if message[0] == '/':
+        await handle_command(message)
+    else:
+        await handle_message(message)
```

## dragonion/modules/tui/chat/utils/handlers/input/message.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-from dragonion_core.proto.web.webmessage import WebBroadcastableBuilder
-
-
-async def handle_message(full_text: str):
-    from dragonion.modules.tui import app
-
-    if not app.user_storage.websocket or not app.user_storage.websocket.open:
-        app.query_one('MessagesContainer').write(
-            f"[red]Error[/]: first connect to onion and join room"
-        )
-        return
-
-    await app.user_storage.websocket.send(
-        WebBroadcastableBuilder(
-            avatar=app.user_storage.avatar,
-            message_content=full_text,
-            from_user=app.identity.username,
-            keys=app.user_storage.keys
-        ).to_json()
-    )
+from dragonion_core.proto.web.webmessage import WebBroadcastableBuilder
+
+
+async def handle_message(full_text: str):
+    from dragonion.modules.tui import app
+
+    if not app.user_storage.websocket or not app.user_storage.websocket.open:
+        app.query_one('MessagesContainer').write(
+            f"[red]Error[/]: first connect to onion and join room"
+        )
+        return
+
+    await app.user_storage.websocket.send(
+        WebBroadcastableBuilder(
+            avatar=app.user_storage.avatar,
+            message_content=full_text,
+            from_user=app.identity.username,
+            keys=app.user_storage.keys
+        ).to_json()
+    )
```

## dragonion/modules/tui/chat/utils/tasks/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from .connect import handle_connect
-from .disconnect import handle_disconnect
-from .message import handle_message
-from .notification import handle_notification
-from .error import handle_error
+from .connect import handle_connect
+from .disconnect import handle_disconnect
+from .message import handle_message
+from .notification import handle_notification
+from .error import handle_error
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/connect.py

 * *Ordering differences only*

```diff
@@ -1,18 +1,18 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-from .helpers import render_time
-
-from dragonion_core.proto.web.webmessage import WebConnectionMessage
-
-
-async def handle_connect(webmessage: WebConnectionMessage):
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    app.user_storage.keys |= {
-        webmessage.username: webmessage.public_key
-    }
-    container.write(
-        f"- Connected {webmessage.username} - "
-        f"{render_time(webmessage.time)}"
-    )
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+from .helpers import render_time
+
+from dragonion_core.proto.web.webmessage import WebConnectionMessage
+
+
+async def handle_connect(webmessage: WebConnectionMessage):
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    app.user_storage.keys |= {
+        webmessage.username: webmessage.public_key
+    }
+    container.write(
+        f"- Connected {webmessage.username} - "
+        f"{render_time(webmessage.time)}"
+    )
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/disconnect.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-from .helpers import render_time
-
-from dragonion_core.proto.web.webmessage import WebDisconnectMessage
-
-
-async def handle_disconnect(webmessage: WebDisconnectMessage):
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    container.write(
-        f"- Disconnected {webmessage.username} - "
-        f"{render_time(webmessage.time)}"
-    )
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+from .helpers import render_time
+
+from dragonion_core.proto.web.webmessage import WebDisconnectMessage
+
+
+async def handle_disconnect(webmessage: WebDisconnectMessage):
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    container.write(
+        f"- Disconnected {webmessage.username} - "
+        f"{render_time(webmessage.time)}"
+    )
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/error.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-from .helpers import render_time
-
-from dragonion_core.proto.web.webmessage import WebErrorMessage
-
-
-async def handle_error(webmessage: WebErrorMessage):
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    container.write(
-        f"[red]- {webmessage.error_message} - "
-        f"{render_time(webmessage.time)}[/]"
-    )
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+from .helpers import render_time
+
+from dragonion_core.proto.web.webmessage import WebErrorMessage
+
+
+async def handle_error(webmessage: WebErrorMessage):
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    container.write(
+        f"[red]- {webmessage.error_message} - "
+        f"{render_time(webmessage.time)}[/]"
+    )
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/helpers.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from datetime import datetime
-
-
-def render_time(time: datetime):
-    return f"[#a5abb3][{time.time().strftime('%H:%M:%S')}][/]"
+from datetime import datetime
+
+
+def render_time(time: datetime):
+    return f"[#a5abb3][{time.time().strftime('%H:%M:%S')}][/]"
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/message.py

 * *Ordering differences only*

```diff
@@ -1,26 +1,26 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-from dragonion.modules.tui.chat.widgets.items.message import Message
-
-from dragonion_core.proto.web.webmessage import WebMessageMessage
-
-
-async def handle_message(webmessage: WebMessageMessage):
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    if not container.last_message or \
-            container.last_message.author != webmessage.username:
-        container.mount_scroll_adaptive(
-            Message(
-                avatar=webmessage.avatar,
-                message=webmessage.decrypt(app.identity),
-                author=webmessage.username,
-                time=webmessage.time
-            )
-        )
-    else:
-        container.last_message.add_message(
-            message=webmessage.decrypt(app.identity),
-            time=webmessage.time
-        )
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+from dragonion.modules.tui.chat.widgets.items.message import Message
+
+from dragonion_core.proto.web.webmessage import WebMessageMessage
+
+
+async def handle_message(webmessage: WebMessageMessage):
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    if not container.last_message or \
+            container.last_message.author != webmessage.username:
+        container.mount_scroll_adaptive(
+            Message(
+                avatar=webmessage.avatar,
+                message=webmessage.decrypt(app.identity),
+                author=webmessage.username,
+                time=webmessage.time
+            )
+        )
+    else:
+        container.last_message.add_message(
+            message=webmessage.decrypt(app.identity),
+            time=webmessage.time
+        )
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/handlers/notification.py

 * *Ordering differences only*

```diff
@@ -1,15 +1,15 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-from .helpers import render_time
-
-from dragonion_core.proto.web.webmessage import WebNotificationMessage
-
-
-async def handle_notification(webmessage: WebNotificationMessage):
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    container.write(
-        f"[blue]- {webmessage.message} - "
-        f"{render_time(webmessage.time)}[/]"
-    )
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+from .helpers import render_time
+
+from dragonion_core.proto.web.webmessage import WebNotificationMessage
+
+
+async def handle_notification(webmessage: WebNotificationMessage):
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    container.write(
+        f"[blue]- {webmessage.message} - "
+        f"{render_time(webmessage.time)}[/]"
+    )
```

## dragonion/modules/tui/chat/utils/tasks/socket_handler/task.py

 * *Ordering differences only*

```diff
@@ -1,44 +1,44 @@
-from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
-
-import websockets.exceptions
-
-from dragonion_core.proto.web.webmessage import WebMessage
-
-from .handlers import (
-    handle_connect,
-    handle_disconnect,
-    handle_message,
-    handle_notification,
-    handle_error
-)
-
-
-async def unknown_message(_):
-    pass
-
-
-async def handle_websocket():
-    from dragonion.modules.tui import app
-
-    container = app.query_one(MessagesContainer)
-
-    async for message in app.user_storage.websocket:
-        try:
-            webmessage = WebMessage.from_json(message)
-
-            await ({
-                "connect": handle_connect,
-                "disconnect": handle_disconnect,
-                "message": handle_message,
-                "notification": handle_notification,
-                "error": handle_error
-            }.get(webmessage.type, unknown_message)(webmessage))
-
-        except websockets.exceptions.ConnectionClosedOK:
-            pass
-        except websockets.exceptions.ConnectionClosed:
-            container.write(
-                f"[bold red]Disconnected[/], consider rejoining"
-            )
-        except Exception as e:
-            container.write(f'[red]Error {e.__class__}[/] in message handler: {e}')
+from dragonion.modules.tui.chat.widgets.containers import MessagesContainer
+
+import websockets.exceptions
+
+from dragonion_core.proto.web.webmessage import WebMessage
+
+from .handlers import (
+    handle_connect,
+    handle_disconnect,
+    handle_message,
+    handle_notification,
+    handle_error
+)
+
+
+async def unknown_message(_):
+    pass
+
+
+async def handle_websocket():
+    from dragonion.modules.tui import app
+
+    container = app.query_one(MessagesContainer)
+
+    async for message in app.user_storage.websocket:
+        try:
+            webmessage = WebMessage.from_json(message)
+
+            await ({
+                "connect": handle_connect,
+                "disconnect": handle_disconnect,
+                "message": handle_message,
+                "notification": handle_notification,
+                "error": handle_error
+            }.get(webmessage.type, unknown_message)(webmessage))
+
+        except websockets.exceptions.ConnectionClosedOK:
+            pass
+        except websockets.exceptions.ConnectionClosed:
+            container.write(
+                f"[bold red]Disconnected[/], consider rejoining"
+            )
+        except Exception as e:
+            container.write(f'[red]Error {e.__class__}[/] in message handler: {e}')
```

## dragonion/modules/tui/chat/widgets/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/widgets/containers.py

 * *Ordering differences only*

```diff
@@ -1,80 +1,80 @@
-from textual.containers import ScrollableContainer
-from textual.widget import Widget
-from textual.widgets import Static
-from textual import events
-
-from textual.css.query import NoMatches
-
-from .items.message import Message
-
-import textwrap
-
-
-class MessagesContainer(ScrollableContainer):
-    DEFAULT_CSS = """
-    MessagesContainer {
-        padding: 1;
-        width: 1fr;
-        height: 1fr;
-        margin-left: 1;
-    }
-    
-    .dragonion_help_logo {
-        content-align: center top;
-        align-horizontal: center;
-        width: 1fr;
-        height: auto;
-    }
-    """
-
-    def _on_mount(self, event: events.Mount) -> None:
-        self.mount(
-            Static(
-                textwrap.dedent("""\
-                            
-                 
-                        
-                       
-                  
-                           
-                    Most modern-looking, encrypted and functional in-console
-                                onion chat that you control! 
-            Use /connect command to establish onion connection, than /join to connect 
-                    to room or /help to get list of all available commands          
-                """), classes='dragonion_help_logo'
-            ),
-        )
-
-    def write(self, text: str, classes: str = '', _id: str = None, no_newline=False):
-        self.mount(w := Static(text + ('\n' if not no_newline else ''),
-                               classes=classes, id=_id, shrink=True))
-        w.scroll_visible(duration=1)
-
-    def mount_scroll(self, widget: Widget):
-        self.mount(widget)
-        widget.scroll_visible(duration=1)
-
-    def mount_scroll_adaptive(self, widget: Widget):
-        self.mount(widget)
-        self.scroll_adaptive_to(widget)
-
-    def scroll_adaptive_to(self, widget: Widget):
-        """
-        Scrolls to specified widget if user didn't scroll up
-        :param widget:
-        :return:
-        """
-        if self.scroll_offset.y == self.max_scroll_y:
-            widget.scroll_visible(duration=1)
-
-    @property
-    def last_message(self) -> Message | None:
-        try:
-            widget = self.query(None).last()
-            if 'message_time' in widget.classes:
-                # noinspection PyTypeChecker
-                return self.query(Message).last()
-            else:
-                return None
-        except NoMatches:
-            return None
+from textual.containers import ScrollableContainer
+from textual.widget import Widget
+from textual.widgets import Static
+from textual import events
+
+from textual.css.query import NoMatches
+
+from .items.message import Message
+
+import textwrap
+
+
+class MessagesContainer(ScrollableContainer):
+    DEFAULT_CSS = """
+    MessagesContainer {
+        padding: 1;
+        width: 1fr;
+        height: 1fr;
+        margin-left: 1;
+    }
+    
+    .dragonion_help_logo {
+        content-align: center top;
+        align-horizontal: center;
+        width: 1fr;
+        height: auto;
+    }
+    """
+
+    def _on_mount(self, event: events.Mount) -> None:
+        self.mount(
+            Static(
+                textwrap.dedent("""\
+                            
+                 
+                        
+                       
+                  
+                           
+                    Most modern-looking, encrypted and functional in-console
+                                onion chat that you control! 
+            Use /connect command to establish onion connection, than /join to connect 
+                    to room or /help to get list of all available commands          
+                """), classes='dragonion_help_logo'
+            ),
+        )
+
+    def write(self, text: str, classes: str = '', _id: str = None, no_newline=False):
+        self.mount(w := Static(text + ('\n' if not no_newline else ''),
+                               classes=classes, id=_id, shrink=True))
+        w.scroll_visible(duration=1)
+
+    def mount_scroll(self, widget: Widget):
+        self.mount(widget)
+        widget.scroll_visible(duration=1)
+
+    def mount_scroll_adaptive(self, widget: Widget):
+        self.mount(widget)
+        self.scroll_adaptive_to(widget)
+
+    def scroll_adaptive_to(self, widget: Widget):
+        """
+        Scrolls to specified widget if user didn't scroll up
+        :param widget:
+        :return:
+        """
+        if self.scroll_offset.y == self.max_scroll_y:
+            widget.scroll_visible(duration=1)
+
+    @property
+    def last_message(self) -> Message | None:
+        try:
+            widget = self.query(None).last()
+            if 'message_time' in widget.classes:
+                # noinspection PyTypeChecker
+                return self.query(Message).last()
+            else:
+                return None
+        except NoMatches:
+            return None
```

## dragonion/modules/tui/chat/widgets/inputs/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/widgets/inputs/message_input.py

 * *Ordering differences only*

```diff
@@ -1,38 +1,38 @@
-from textual import on
-from textual.app import ComposeResult
-from textual.containers import Horizontal
-from textual.widgets import Input, Button
-
-from ...utils.handlers.input.general import handle_input_submit
-
-
-class InputContainer(Horizontal):
-    DEFAULT_CSS = """
-    .input_field {
-        width: 1fr;
-        border: tall $accent;
-    }
-    .input_submit {
-        min-width: 7;
-        width: 7;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        self.classes = "input"
-
-        yield Input(
-            classes="input_field",
-            id="chat_input_field"
-        )
-        yield Button(
-            ">",
-            classes="input_submit",
-            variant="primary",
-            id="chat_input_submit_button"
-        )
-
-    @on(Button.Pressed, "#chat_input_submit_button")
-    @on(Input.Submitted, "#chat_input_field")
-    async def on_submit(self):
-        await handle_input_submit()
+from textual import on
+from textual.app import ComposeResult
+from textual.containers import Horizontal
+from textual.widgets import Input, Button
+
+from ...utils.handlers.input.general import handle_input_submit
+
+
+class InputContainer(Horizontal):
+    DEFAULT_CSS = """
+    .input_field {
+        width: 1fr;
+        border: tall $accent;
+    }
+    .input_submit {
+        min-width: 7;
+        width: 7;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        self.classes = "input"
+
+        yield Input(
+            classes="input_field",
+            id="chat_input_field"
+        )
+        yield Button(
+            ">",
+            classes="input_submit",
+            variant="primary",
+            id="chat_input_submit_button"
+        )
+
+    @on(Button.Pressed, "#chat_input_submit_button")
+    @on(Input.Submitted, "#chat_input_field")
+    async def on_submit(self):
+        await handle_input_submit()
```

## dragonion/modules/tui/chat/widgets/items/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/chat/widgets/items/message.py

 * *Ordering differences only*

```diff
@@ -1,132 +1,132 @@
-from textual.app import ComposeResult
-from textual.widgets import Static, Label
-from textual import events
-
-from datetime import datetime
-
-
-class Avatar(Static):
-    DEFAULT_CSS = """
-    Avatar {
-        width: auto;
-    }
-    """
-
-    def __init__(self, symb: str):
-        self.symb = symb
-        super().__init__()
-
-    def compose(self) -> ComposeResult:
-        yield Label(f"({self.symb}) ")
-
-
-class MessageHeader(Static):
-    DEFAULT_CSS = """
-    MessageHeader {
-        layout: horizontal;
-        background: $boost;
-        width: auto;
-    }
-    """
-
-    def __init__(self, message: str, time: datetime):
-        self.message = message
-        self.time = time
-        super().__init__()
-
-    def compose(self) -> ComposeResult:
-        yield Label(f"[bold]{self.message}[/]")
-        yield Label(" ")
-        yield Label(f"[#a5abb3][{self.time.time().strftime('%H:%M:%S')}][/]")
-
-
-class MessageContent(Static):
-    DEFAULT_CSS = """
-    MessageContent {
-        layout: horizontal;
-        width: 1fr;
-        height: auto;
-    }
-    
-    ._message_content_text {
-        width: auto;
-        height: auto;
-        margin-right: 5;
-    }
-    
-    .message_time {
-        height: auto;
-        offset-x: -3;
-    }
-    """
-
-    def __init__(self, message: str, time: datetime):
-        self.message = message
-        self.time = time
-        super().__init__()
-
-    def _on_mount(self, event: events.Mount) -> None:
-        self.query_one('.message_time').visible = False
-
-    def _on_enter(self, event: events.Focus) -> None:
-        self.query_one('.message_time').visible = True
-
-    def _on_leave(self, event: events.Blur) -> None:
-        self.query_one('.message_time').visible = False
-
-    def compose(self) -> ComposeResult:
-        yield Static(self.message, classes='_message_content_text', shrink=True)
-        yield Static(
-            f"[#a5abb3][{self.time.time().strftime('%H:%M:%S')}][/]",
-            classes='message_time'
-        )
-
-
-class TextMessage(Static):
-    DEFAULT_CSS = """
-    TextMessage {
-        layout: vertical;
-        width: auto;
-    }
-    """
-
-    def __init__(self, author: str, message: str, time: datetime):
-        self.author = author
-        self.message = message
-        self.time = time
-        super().__init__()
-
-    def compose(self) -> ComposeResult:
-        yield MessageHeader(self.author, self.time)
-        yield MessageContent(self.message, self.time)
-
-
-class Message(Static):
-    DEFAULT_CSS = """
-    Message {
-        layout: horizontal;
-        margin-bottom: 1;
-        height: auto;
-    }
-    """
-
-    def __init__(self, avatar: str, author: str, message: str, time: datetime):
-        self.avatar = avatar
-        self.author = author
-        self.message = message
-        self.time = time
-        super().__init__()
-
-    def compose(self) -> ComposeResult:
-        yield Avatar(symb=self.avatar)
-        yield TextMessage(
-            author=self.author,
-            message=self.message,
-            time=self.time
-        )
-
-    def add_message(self, message: str, time: datetime):
-        self.query_one(TextMessage).mount(
-            m := MessageContent(message, time)
-        )
-        self.app.query_one('MessagesContainer').scroll_adaptive_to(m)
+from textual.app import ComposeResult
+from textual.widgets import Static, Label
+from textual import events
+
+from datetime import datetime
+
+
+class Avatar(Static):
+    DEFAULT_CSS = """
+    Avatar {
+        width: auto;
+    }
+    """
+
+    def __init__(self, symb: str):
+        self.symb = symb
+        super().__init__()
+
+    def compose(self) -> ComposeResult:
+        yield Label(f"({self.symb}) ")
+
+
+class MessageHeader(Static):
+    DEFAULT_CSS = """
+    MessageHeader {
+        layout: horizontal;
+        background: $boost;
+        width: auto;
+    }
+    """
+
+    def __init__(self, message: str, time: datetime):
+        self.message = message
+        self.time = time
+        super().__init__()
+
+    def compose(self) -> ComposeResult:
+        yield Label(f"[bold]{self.message}[/]")
+        yield Label(" ")
+        yield Label(f"[#a5abb3][{self.time.time().strftime('%H:%M:%S')}][/]")
+
+
+class MessageContent(Static):
+    DEFAULT_CSS = """
+    MessageContent {
+        layout: horizontal;
+        width: 1fr;
+        height: auto;
+    }
+    
+    ._message_content_text {
+        width: auto;
+        height: auto;
+        margin-right: 5;
+    }
+    
+    .message_time {
+        height: auto;
+        offset-x: -3;
+    }
+    """
+
+    def __init__(self, message: str, time: datetime):
+        self.message = message
+        self.time = time
+        super().__init__()
+
+    def _on_mount(self, event: events.Mount) -> None:
+        self.query_one('.message_time').visible = False
+
+    def _on_enter(self, event: events.Focus) -> None:
+        self.query_one('.message_time').visible = True
+
+    def _on_leave(self, event: events.Blur) -> None:
+        self.query_one('.message_time').visible = False
+
+    def compose(self) -> ComposeResult:
+        yield Static(self.message, classes='_message_content_text', shrink=True)
+        yield Static(
+            f"[#a5abb3][{self.time.time().strftime('%H:%M:%S')}][/]",
+            classes='message_time'
+        )
+
+
+class TextMessage(Static):
+    DEFAULT_CSS = """
+    TextMessage {
+        layout: vertical;
+        width: auto;
+    }
+    """
+
+    def __init__(self, author: str, message: str, time: datetime):
+        self.author = author
+        self.message = message
+        self.time = time
+        super().__init__()
+
+    def compose(self) -> ComposeResult:
+        yield MessageHeader(self.author, self.time)
+        yield MessageContent(self.message, self.time)
+
+
+class Message(Static):
+    DEFAULT_CSS = """
+    Message {
+        layout: horizontal;
+        margin-bottom: 1;
+        height: auto;
+    }
+    """
+
+    def __init__(self, avatar: str, author: str, message: str, time: datetime):
+        self.avatar = avatar
+        self.author = author
+        self.message = message
+        self.time = time
+        super().__init__()
+
+    def compose(self) -> ComposeResult:
+        yield Avatar(symb=self.avatar)
+        yield TextMessage(
+            author=self.author,
+            message=self.message,
+            time=self.time
+        )
+
+    def add_message(self, message: str, time: datetime):
+        self.query_one(TextMessage).mount(
+            m := MessageContent(message, time)
+        )
+        self.app.query_one('MessagesContainer').scroll_adaptive_to(m)
```

## dragonion/modules/tui/helpers/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/helpers/storage.py

 * *Ordering differences only*

```diff
@@ -1,20 +1,20 @@
-from dragonion.utils.core.emoji import random_emoji
-from dataclasses import dataclass, field
-
-import websockets.client
-
-from socks import socksocket
-
-from dragonion.utils.onion import Onion
-
-
-@dataclass
-class UserStorage:
-    avatar: str = random_emoji()
-    keys: dict[str, bytes] = field(default_factory=dict)
-    host: str = None
-    onion: Onion = None
-    sock: socksocket = None
-    websocket: websockets.client.WebSocketClientProtocol = None
-    connect: bool = False
-    dev_proxy_port: int = None
+from dragonion.utils.core.emoji import random_emoji
+from dataclasses import dataclass, field
+
+import websockets.client
+
+from socks import socksocket
+
+from dragonion.utils.onion import Onion
+
+
+@dataclass
+class UserStorage:
+    avatar: str = random_emoji()
+    keys: dict[str, bytes] = field(default_factory=dict)
+    host: str = None
+    onion: Onion = None
+    sock: socksocket = None
+    websocket: websockets.client.WebSocketClientProtocol = None
+    connect: bool = False
+    dev_proxy_port: int = None
```

## dragonion/modules/tui/identity/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/identity/identity.py

 * *Ordering differences only*

```diff
@@ -1,28 +1,28 @@
-from textual.app import ComposeResult
-from textual.widgets import Static
-from textual.containers import Center
-from .widgets.containers import GenerateIdentityContainer
-
-
-class IdentityWidget(Static):
-    DEFAULT_CSS = """
-    IdentityWidget {
-        height: 100%;
-        layout: vertical;
-        align-vertical: middle;
-    }
-
-    GenerateIdentityContainer {
-        align: center middle; 
-        height: 1fr;
-        max-width: 50%;
-    }
-    """
-
-    def _on_compose(self) -> None:
-        from .. import app
-        # noinspection PyTypeChecker
-        app.title = 'dragonion - identity'
-
-    def compose(self) -> ComposeResult:
-        yield Center(GenerateIdentityContainer())
+from textual.app import ComposeResult
+from textual.widgets import Static
+from textual.containers import Center
+from .widgets.containers import GenerateIdentityContainer
+
+
+class IdentityWidget(Static):
+    DEFAULT_CSS = """
+    IdentityWidget {
+        height: 100%;
+        layout: vertical;
+        align-vertical: middle;
+    }
+
+    GenerateIdentityContainer {
+        align: center middle; 
+        height: 1fr;
+        max-width: 50%;
+    }
+    """
+
+    def _on_compose(self) -> None:
+        from .. import app
+        # noinspection PyTypeChecker
+        app.title = 'dragonion - identity'
+
+    def compose(self) -> ComposeResult:
+        yield Center(GenerateIdentityContainer())
```

## dragonion/modules/tui/identity/utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/identity/widgets/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/modules/tui/identity/widgets/containers.py

 * *Ordering differences only*

```diff
@@ -1,53 +1,53 @@
-from textual import on
-from textual.app import ComposeResult
-from .inputs import UsernameInputLayout
-
-from textual.widgets import (
-    Static,
-    Input,
-    Button,
-    LoadingIndicator
-)
-from textual.containers import Center
-
-
-class GenerateIdentityContainer(Static):
-    DEFAULT_CSS = """
-    #generate_identity_button {
-        margin-top: 1;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        yield Center(UsernameInputLayout())
-        yield Center(Button(
-            label='Generate identity',
-            name='generate_identity_button',
-            variant='success',
-            id='generate_identity_button',
-            disabled=True
-        ))
-
-    @on(Button.Pressed, "#generate_identity_button")
-    @on(Input.Submitted, "#username_input")
-    def on_generate_button_pressed(self, _: Button.Pressed):
-        """
-        On generate button press
-        :param _:
-        :return: Modifies global app.identity to generated
-        """
-        try:
-            from ... import app
-            from dragonion_core.proto.encryption.identity import Identity
-
-            app.query_one('IdentityWidget').remove()
-            app.mount(LoadingIndicator())
-
-            if _username := self.query_one('#username_input', expect_type=Input).value:
-                app.identity = Identity(
-                    username=_username
-                )
-        except Exception as e:
-            assert e
-            from ... import app
-            app.bell()
+from textual import on
+from textual.app import ComposeResult
+from .inputs import UsernameInputLayout
+
+from textual.widgets import (
+    Static,
+    Input,
+    Button,
+    LoadingIndicator
+)
+from textual.containers import Center
+
+
+class GenerateIdentityContainer(Static):
+    DEFAULT_CSS = """
+    #generate_identity_button {
+        margin-top: 1;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        yield Center(UsernameInputLayout())
+        yield Center(Button(
+            label='Generate identity',
+            name='generate_identity_button',
+            variant='success',
+            id='generate_identity_button',
+            disabled=True
+        ))
+
+    @on(Button.Pressed, "#generate_identity_button")
+    @on(Input.Submitted, "#username_input")
+    def on_generate_button_pressed(self, _: Button.Pressed):
+        """
+        On generate button press
+        :param _:
+        :return: Modifies global app.identity to generated
+        """
+        try:
+            from ... import app
+            from dragonion_core.proto.encryption.identity import Identity
+
+            app.query_one('IdentityWidget').remove()
+            app.mount(LoadingIndicator())
+
+            if _username := self.query_one('#username_input', expect_type=Input).value:
+                app.identity = Identity(
+                    username=_username
+                )
+        except Exception as e:
+            assert e
+            from ... import app
+            app.bell()
```

## dragonion/modules/tui/identity/widgets/inputs.py

 * *Ordering differences only*

```diff
@@ -1,35 +1,35 @@
-from textual import on
-from textual.app import ComposeResult
-from textual.widgets import (
-    Static,
-    Input,
-    Button
-)
-from textual.validation import Length
-
-
-class UsernameInputLayout(Static):
-    DEFAULT_CSS = """
-    #username_input {
-        margin-top: 1;
-    }
-    """
-
-    def compose(self) -> ComposeResult:
-        yield Input(
-            placeholder='username',
-            id='username_input',
-            validators=[
-                Length(
-                    minimum=4,
-                    maximum=14,
-                    failure_description='Username length must be from 4 to 14 symbols'
-                )
-            ]
-        )
-
-    @on(Input.Changed, '#username_input')
-    def on_username_validate(self, event: Input.Changed):
-        from ... import app
-        app.query_one('#generate_identity_button', expect_type=Button).disabled = \
-            not event.validation_result.is_valid
+from textual import on
+from textual.app import ComposeResult
+from textual.widgets import (
+    Static,
+    Input,
+    Button
+)
+from textual.validation import Length
+
+
+class UsernameInputLayout(Static):
+    DEFAULT_CSS = """
+    #username_input {
+        margin-top: 1;
+    }
+    """
+
+    def compose(self) -> ComposeResult:
+        yield Input(
+            placeholder='username',
+            id='username_input',
+            validators=[
+                Length(
+                    minimum=4,
+                    maximum=14,
+                    failure_description='Username length must be from 4 to 14 symbols'
+                )
+            ]
+        )
+
+    @on(Input.Changed, '#username_input')
+    def on_username_validate(self, event: Input.Changed):
+        from ... import app
+        app.query_one('#generate_identity_button', expect_type=Button).disabled = \
+            not event.validation_result.is_valid
```

## dragonion/modules/tui/tui.py

 * *Ordering differences only*

```diff
@@ -1,78 +1,78 @@
-import asyncio
-
-from textual.app import App, ComposeResult
-from textual.reactive import reactive
-from textual.widgets import Header, LoadingIndicator
-from textual.css.query import NoMatches
-
-
-from .authentication import authentication
-from .authentication.utils.results import ServiceAuthResult
-
-from .identity import identity
-
-from .chat import chat
-
-from .helpers.storage import UserStorage
-
-from dragonion_core.proto.encryption.identity import Identity
-
-from ezzthread import threaded
-
-
-class DragonionTuiApp(App):
-    _pre_service_auth = None
-    _pre_username = None
-    service_auth = reactive(None)
-    identity = reactive(None)
-    user_storage = UserStorage()
-
-    def compose(self) -> ComposeResult:
-        yield Header()
-        if not self._pre_service_auth:
-            yield authentication.LoginWidget()
-
-    def _on_compose(self) -> None:
-        if self._pre_service_auth is not None:
-            self.service_auth = self._pre_service_auth
-
-    def watch_service_auth(self):
-        if isinstance(self.service_auth, ServiceAuthResult):
-            try:
-                self.query_one(authentication.LoginWidget).remove()
-            except NoMatches:
-                pass
-
-            if self._pre_username:
-                self.mount(LoadingIndicator())
-                self.identity = Identity(self._pre_username)
-            else:
-                self.mount(identity.IdentityWidget())
-
-    async def watch_identity(self):
-        if isinstance(self.identity, Identity):
-            try:
-                threaded(self.identity.generate)()
-                while self.identity.private_key is None:
-                    await asyncio.sleep(0.1)
-                await self.query_one(LoadingIndicator).remove()
-            except NoMatches:
-                pass
-
-            if self.identity and isinstance(self.service_auth, ServiceAuthResult) \
-                    and len(list(self.query('ChatWidget').results())) == 0:
-                await self.mount(chat.ChatWidget(
-                    service_auth=self.service_auth,
-                    identity=self.identity
-                ))
-                if self.user_storage.connect:
-                    from .chat.utils.handlers.input.command.commands.connect import \
-                        connect_command
-                    await connect_command(list())
-
-    def _on_exit_app(self) -> None:
-        if self.user_storage.onion:
-            self.user_storage.onion.cleanup()
-
-
-app = DragonionTuiApp()
+import asyncio
+
+from textual.app import App, ComposeResult
+from textual.reactive import reactive
+from textual.widgets import Header, LoadingIndicator
+from textual.css.query import NoMatches
+
+
+from .authentication import authentication
+from .authentication.utils.results import ServiceAuthResult
+
+from .identity import identity
+
+from .chat import chat
+
+from .helpers.storage import UserStorage
+
+from dragonion_core.proto.encryption.identity import Identity
+
+from ezzthread import threaded
+
+
+class DragonionTuiApp(App):
+    _pre_service_auth = None
+    _pre_username = None
+    service_auth = reactive(None)
+    identity = reactive(None)
+    user_storage = UserStorage()
+
+    def compose(self) -> ComposeResult:
+        yield Header()
+        if not self._pre_service_auth:
+            yield authentication.LoginWidget()
+
+    def _on_compose(self) -> None:
+        if self._pre_service_auth is not None:
+            self.service_auth = self._pre_service_auth
+
+    def watch_service_auth(self):
+        if isinstance(self.service_auth, ServiceAuthResult):
+            try:
+                self.query_one(authentication.LoginWidget).remove()
+            except NoMatches:
+                pass
+
+            if self._pre_username:
+                self.mount(LoadingIndicator())
+                self.identity = Identity(self._pre_username)
+            else:
+                self.mount(identity.IdentityWidget())
+
+    async def watch_identity(self):
+        if isinstance(self.identity, Identity):
+            try:
+                threaded(self.identity.generate)()
+                while self.identity.private_key is None:
+                    await asyncio.sleep(0.1)
+                await self.query_one(LoadingIndicator).remove()
+            except NoMatches:
+                pass
+
+            if self.identity and isinstance(self.service_auth, ServiceAuthResult) \
+                    and len(list(self.query('ChatWidget').results())) == 0:
+                await self.mount(chat.ChatWidget(
+                    service_auth=self.service_auth,
+                    identity=self.identity
+                ))
+                if self.user_storage.connect:
+                    from .chat.utils.handlers.input.command.commands.connect import \
+                        connect_command
+                    await connect_command(list())
+
+    def _on_exit_app(self) -> None:
+        if self.user_storage.onion:
+            self.user_storage.onion.cleanup()
+
+
+app = DragonionTuiApp()
```

## dragonion/utils/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/utils/core/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-pass
+pass
```

## dragonion/utils/core/const.py

 * *Ordering differences only*

```diff
@@ -1,4 +1,4 @@
-import sys
-
-
-portable = getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')
+import sys
+
+
+portable = getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS')
```

## dragonion/utils/core/dirs.py

 * *Ordering differences only*

```diff
@@ -1,100 +1,100 @@
-import os
-import sys
-import platform
-import shutil
-
-from . import const
-
-
-def get_resource_path(filename):
-    """
-    Get path to file in resources folder
-    :param filename: Resource name to get path
-    :return:
-    """
-    if const.portable:
-        # noinspection PyUnresolvedReferences, PyProtectedMember
-        application_path = os.path.join(os.path.abspath(sys._MEIPASS), 'resources')
-    else:
-        import dragonion
-        application_path = os.path.join(os.path.dirname(dragonion.__file__),
-                                        'resources')
-
-    return os.path.join(application_path, filename)
-
-
-def get_tor_paths():
-    """
-    Get path to tor executable and download it if not exists. Will exit application on
-    ARM systems if tor is not installed.
-    :return: Path to tor executable
-    """
-    if (platform.system() != "Darwin" and
-            platform.machine().lower() in ['aarch64', 'arm64']):
-        if shutil.which('tor'):
-            return 'tor'
-        else:
-            print('Detected ARM system and tor is not installed or added to PATH. '
-                  'Please, consider reading documentation and installing application '
-                  'properly')
-            sys.exit(1)
-
-    else:
-        from ..onion.tor_downloader import download_tor
-        if platform.system() in ["Linux", "Darwin"]:
-            tor_path = os.path.join(build_data_dir(), 'tor/tor')
-        elif platform.system() == "Windows":
-            tor_path = os.path.join(build_data_dir(), 'tor/tor.exe')
-        else:
-            raise Exception("Platform not supported")
-
-        if not os.path.isfile(tor_path):
-            download_tor(dist=build_data_dir())
-
-        return tor_path
-
-
-def build_data_dir():
-    """
-    Get local data dir
-    :return:
-    """
-    if const.portable:
-        # noinspection PyUnresolvedReferences, PyProtectedMember
-        dragonion_data_dir = os.path.join(os.path.abspath(sys._MEIPASS), 'data')
-    else:
-        import dragonion
-        dragonion_data_dir = os.path.join(os.path.dirname(dragonion.__file__), 'data')
-
-    os.makedirs(dragonion_data_dir, exist_ok=True)
-    return dragonion_data_dir
-
-
-def build_tmp_dir():
-    """
-    Get "tmp" dir in data directory
-    :return:
-    """
-    tmp_dir = os.path.join(build_data_dir(), "tmp")
-    os.makedirs(tmp_dir, exist_ok=True)
-    return tmp_dir
-
-
-def build_persistent_dir():
-    """
-    Get "persistent" dir in data directory
-    :return:
-    """
-    persistent_dir = os.path.join(build_data_dir(), "persistent")
-    os.makedirs(persistent_dir, exist_ok=True)
-    return persistent_dir
-
-
-def build_tor_data_dir():
-    """
-    Get "tor_data" dir in data directory
-    :return:
-    """
-    tor_dir = os.path.join(build_data_dir(), "tor_data")
-    os.makedirs(tor_dir, exist_ok=True)
-    return tor_dir
+import os
+import sys
+import platform
+import shutil
+
+from . import const
+
+
+def get_resource_path(filename):
+    """
+    Get path to file in resources folder
+    :param filename: Resource name to get path
+    :return:
+    """
+    if const.portable:
+        # noinspection PyUnresolvedReferences, PyProtectedMember
+        application_path = os.path.join(os.path.abspath(sys._MEIPASS), 'resources')
+    else:
+        import dragonion
+        application_path = os.path.join(os.path.dirname(dragonion.__file__),
+                                        'resources')
+
+    return os.path.join(application_path, filename)
+
+
+def get_tor_paths():
+    """
+    Get path to tor executable and download it if not exists. Will exit application on
+    ARM systems if tor is not installed.
+    :return: Path to tor executable
+    """
+    if (platform.system() != "Darwin" and
+            platform.machine().lower() in ['aarch64', 'arm64']):
+        if shutil.which('tor'):
+            return 'tor'
+        else:
+            print('Detected ARM system and tor is not installed or added to PATH. '
+                  'Please, consider reading documentation and installing application '
+                  'properly')
+            sys.exit(1)
+
+    else:
+        from ..onion.tor_downloader import download_tor
+        if platform.system() in ["Linux", "Darwin"]:
+            tor_path = os.path.join(build_data_dir(), 'tor/tor')
+        elif platform.system() == "Windows":
+            tor_path = os.path.join(build_data_dir(), 'tor/tor.exe')
+        else:
+            raise Exception("Platform not supported")
+
+        if not os.path.isfile(tor_path):
+            download_tor(dist=build_data_dir())
+
+        return tor_path
+
+
+def build_data_dir():
+    """
+    Get local data dir
+    :return:
+    """
+    if const.portable:
+        # noinspection PyUnresolvedReferences, PyProtectedMember
+        dragonion_data_dir = os.path.join(os.path.abspath(sys._MEIPASS), 'data')
+    else:
+        import dragonion
+        dragonion_data_dir = os.path.join(os.path.dirname(dragonion.__file__), 'data')
+
+    os.makedirs(dragonion_data_dir, exist_ok=True)
+    return dragonion_data_dir
+
+
+def build_tmp_dir():
+    """
+    Get "tmp" dir in data directory
+    :return:
+    """
+    tmp_dir = os.path.join(build_data_dir(), "tmp")
+    os.makedirs(tmp_dir, exist_ok=True)
+    return tmp_dir
+
+
+def build_persistent_dir():
+    """
+    Get "persistent" dir in data directory
+    :return:
+    """
+    persistent_dir = os.path.join(build_data_dir(), "persistent")
+    os.makedirs(persistent_dir, exist_ok=True)
+    return persistent_dir
+
+
+def build_tor_data_dir():
+    """
+    Get "tor_data" dir in data directory
+    :return:
+    """
+    tor_dir = os.path.join(build_data_dir(), "tor_data")
+    os.makedirs(tor_dir, exist_ok=True)
+    return tor_dir
```

## dragonion/utils/core/emoji.py

 * *Ordering differences only*

```diff
@@ -1,27 +1,27 @@
-from itertools import accumulate
-from bisect import bisect
-from random import randrange
-
-
-def random_emoji():
-    emoji_ranges = [
-        ('\U0001F300', '\U0001F579'),
-        ('\U0001F57B', '\U0001F5A3'),
-        ('\U0001F5A5', '\U0001F5FF')
-    ]
-
-    count = [ord(r[-1]) - ord(r[0]) + 1 for r in emoji_ranges]
-    weight_distr = list(accumulate(count))
-
-    point = randrange(weight_distr[-1])
-
-    emoji_range_idx = bisect(weight_distr, point)
-    emoji_range = emoji_ranges[emoji_range_idx]
-
-    point_in_range = point
-    if emoji_range_idx != 0:
-        point_in_range = point - weight_distr[emoji_range_idx - 1]
-
-    emoji = str(chr(ord(emoji_range[0]) + point_in_range))
-
-    return emoji
+from itertools import accumulate
+from bisect import bisect
+from random import randrange
+
+
+def random_emoji():
+    emoji_ranges = [
+        ('\U0001F300', '\U0001F579'),
+        ('\U0001F57B', '\U0001F5A3'),
+        ('\U0001F5A5', '\U0001F5FF')
+    ]
+
+    count = [ord(r[-1]) - ord(r[0]) + 1 for r in emoji_ranges]
+    weight_distr = list(accumulate(count))
+
+    point = randrange(weight_distr[-1])
+
+    emoji_range_idx = bisect(weight_distr, point)
+    emoji_range = emoji_ranges[emoji_range_idx]
+
+    point_in_range = point
+    if emoji_range_idx != 0:
+        point_in_range = point - weight_distr[emoji_range_idx - 1]
+
+    emoji = str(chr(ord(emoji_range[0]) + point_in_range))
+
+    return emoji
```

## dragonion/utils/onion/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-from .onion import Onion
-
-__all__ = [
-    'Onion'
-]
+from .onion import Onion
+
+__all__ = [
+    'Onion'
+]
```

## dragonion/utils/onion/auth.py

 * *Ordering differences only*

```diff
@@ -1,30 +1,30 @@
-import os
-from dragonion_core.proto.file import AuthFile
-
-
-def create_service_auth(
-        tor_data_directory_name: str,
-        service_name: str = None,
-        auth_strings: tuple[str, str] = None,
-) -> str:
-    """
-    Creates .auth_private file to endpoint be accessible
-    :param tor_data_directory_name: Current temp directory of tor
-    :param service_name: Name of .auth file user got from server hoster
-    :param auth_strings: service_id, key
-    :return: Returns .onion url of service
-    """
-    if service_name:
-        auth = AuthFile(service_name)
-        with open(os.path.join(os.path.join(tor_data_directory_name, 'auth'),
-                               'service.auth_private'), 'w') as f:
-            f.write(auth['auth'])
-
-        return auth['host']
-    elif auth_strings[0] and auth_strings[1]:
-        with open(os.path.join(os.path.join(tor_data_directory_name, 'auth'),
-                               'service.auth_private'), 'w') as f:
-            f.write(f'{auth_strings[0]}:descriptor:'
-                    f'x25519:{auth_strings[1]}')
-
-        return f'{auth_strings[1]}.onion'
+import os
+from dragonion_core.proto.file import AuthFile
+
+
+def create_service_auth(
+        tor_data_directory_name: str,
+        service_name: str = None,
+        auth_strings: tuple[str, str] = None,
+) -> str:
+    """
+    Creates .auth_private file to endpoint be accessible
+    :param tor_data_directory_name: Current temp directory of tor
+    :param service_name: Name of .auth file user got from server hoster
+    :param auth_strings: service_id, key
+    :return: Returns .onion url of service
+    """
+    if service_name:
+        auth = AuthFile(service_name)
+        with open(os.path.join(os.path.join(tor_data_directory_name, 'auth'),
+                               'service.auth_private'), 'w') as f:
+            f.write(auth['auth'])
+
+        return auth['host']
+    elif auth_strings[0] and auth_strings[1]:
+        with open(os.path.join(os.path.join(tor_data_directory_name, 'auth'),
+                               'service.auth_private'), 'w') as f:
+            f.write(f'{auth_strings[0]}:descriptor:'
+                    f'x25519:{auth_strings[1]}')
+
+        return f'{auth_strings[1]}.onion'
```

## dragonion/utils/onion/onion.py

 * *Ordering differences only*

```diff
@@ -1,211 +1,211 @@
-from stem.control import Controller
-from .stem_process import launch_tor_with_config
-
-from rich import print
-import socket
-import random
-import os
-import psutil
-import tempfile
-import platform
-import time
-
-from asyncio import subprocess
-
-from dragonion.utils.core import dirs
-
-
-def get_available_port(min_port, max_port):
-    with socket.socket() as tmpsock:
-        while True:
-            try:
-                tmpsock.bind(("127.0.0.1", random.randint(min_port, max_port)))
-                break
-            except OSError:
-                pass
-        _, port = tmpsock.getsockname()
-    return port
-
-
-class Onion(object):
-    c: Controller
-    tor_control_socket: str | None
-    tor_control_port: int | None
-    tor_torrc: str
-    tor_socks_port: int
-    tor_cookie_auth_file: str
-    tor_path: str = dirs.get_tor_paths()
-    tor_proc: subprocess.Process | None
-    connected_to_tor: bool = False
-    auth_string: str
-    graceful_close_onions: list = list()
-
-    def __init__(self):
-        self.tor_data_directory = tempfile.TemporaryDirectory(
-            dir=dirs.build_tmp_dir()
-        )
-        self.tor_data_directory_name = self.tor_data_directory.name
-        os.makedirs(os.path.join(self.tor_data_directory_name, 'auth'))
-
-    def kill_same_tor(self):
-        """
-        Kills tor process that looks like process to be created now
-        """
-        for proc in psutil.process_iter(["pid", "name", "username"]):
-            try:
-                cmdline = proc.cmdline()
-                if (
-                        cmdline[0] == self.tor_path
-                        and cmdline[1] == "-f"
-                        and cmdline[2] == self.tor_torrc
-                ):
-                    proc.terminate()
-                    proc.wait()
-                    break
-            except Exception as e:
-                assert e
-
-    def get_config(self, tor_data_directory_name: str) -> dict:
-        """
-        Build config dict for launching tor
-        :param tor_data_directory_name: Data directory for tor, can be generated
-                                        using code from core/dirs
-        :return:
-        """
-        self.tor_cookie_auth_file = os.path.join(tor_data_directory_name, "cookie")
-        try:
-            self.tor_socks_port = get_available_port(1000, 65535)
-        except Exception as e:
-            print(f"Cannot bind any port for socks proxy: {e}")
-        self.tor_torrc = os.path.join(tor_data_directory_name, "torrc")
-
-        self.kill_same_tor()
-
-        config = {
-            'DataDirectory': tor_data_directory_name,
-            'SocksPort': str(self.tor_socks_port),
-            'CookieAuthentication': '1',
-            'CookieAuthFile': self.tor_cookie_auth_file,
-            'ClientOnionAuthDir': os.path.join(tor_data_directory_name, 'auth'),
-            'AvoidDiskWrites': '1',
-            'Log': [
-                'NOTICE stdout'
-            ]
-        }
-
-        if platform.system() in ["Windows", "Darwin"] or \
-                len(tor_data_directory_name) > 90:
-            try:
-                self.tor_control_port = get_available_port(1000, 65535)
-                config = config | {"ControlPort": str(self.tor_control_port)}
-            except Exception as e:
-                print(f"Cannot bind any control port: {e}")
-            self.tor_control_socket = None
-        else:
-            self.tor_control_port = None
-            self.tor_control_socket = os.path.abspath(os.path.join(
-                tor_data_directory_name, "control_socket"
-            ))
-            config = config | {"ControlSocket": str(self.tor_control_socket)}
-
-        return config
-
-    async def connect(self, init_msg_handler=print):
-        """
-        Connect to tor network
-        :param init_msg_handler: Function that will print logs
-        :return:
-        """
-        self.tor_proc = await launch_tor_with_config(
-            config=self.get_config(self.tor_data_directory_name),
-            tor_cmd=self.tor_path,
-            take_ownership=True,
-            init_msg_handler=init_msg_handler
-        )
-
-        time.sleep(2)
-
-        if not self.tor_control_socket:
-            self.c = Controller.from_port(port=self.tor_control_port)
-            self.c.authenticate()
-        else:
-            self.c = Controller.from_socket_file(path=self.tor_control_socket)
-            self.c.authenticate()
-
-        self.connected_to_tor = True
-
-    def is_authenticated(self):
-        """
-        Check if controller authenticated
-        :return:
-        """
-        if self.c is not None:
-            return self.c.is_authenticated()
-        else:
-            return False
-
-    def cleanup(self):
-        """
-        Stop tor and clean up (hopefully) all footprints
-        :return:
-        """
-        if self.tor_proc:
-            try:
-                rendezvous_circuit_ids = []
-                for c in self.c.get_circuits():
-                    if (
-                            c.purpose == "HS_SERVICE_REND"
-                            and c.rend_query in self.graceful_close_onions
-                    ):
-                        rendezvous_circuit_ids.append(c.id)
-
-                symbols = list("\\|/-")
-                symbols_i = 0
-
-                while True:
-                    num_rend_circuits = 0
-                    for c in self.c.get_circuits():
-                        if c.id in rendezvous_circuit_ids:
-                            num_rend_circuits += 1
-
-                    if num_rend_circuits == 0:
-                        print(
-                            "\rTor rendezvous circuits have closed" + " " * 20
-                        )
-                        break
-
-                    if num_rend_circuits == 1:
-                        circuits = "circuit"
-                    else:
-                        circuits = "circuits"
-                    print(
-                        f"\rWaiting for {num_rend_circuits} Tor rendezvous {circuits} "
-                        f"to close {symbols[symbols_i]} ",
-                        end="",
-                    )
-                    symbols_i = (symbols_i + 1) % len(symbols)
-                    time.sleep(1)
-            except Exception as e:
-                print(e)
-
-            try:
-                self.tor_proc.terminate()
-                time.sleep(0.2)
-            except Exception as e:
-                assert e
-            try:
-                self.tor_proc.kill()
-                time.sleep(0.2)
-            except Exception as e:
-                assert e
-            self.tor_proc = None
-
-        self.connected_to_tor = False
-
-        try:
-            self.tor_data_directory.cleanup()
-        except Exception as e:
-            print(f'Cannot cleanup temporary directory: {e}')
-
-    def get_tor_socks_port(self):
-        return "127.0.0.1", self.tor_socks_port
+from stem.control import Controller
+from .stem_process import launch_tor_with_config
+
+from rich import print
+import socket
+import random
+import os
+import psutil
+import tempfile
+import platform
+import time
+
+from asyncio import subprocess
+
+from dragonion.utils.core import dirs
+
+
+def get_available_port(min_port, max_port):
+    with socket.socket() as tmpsock:
+        while True:
+            try:
+                tmpsock.bind(("127.0.0.1", random.randint(min_port, max_port)))
+                break
+            except OSError:
+                pass
+        _, port = tmpsock.getsockname()
+    return port
+
+
+class Onion(object):
+    c: Controller
+    tor_control_socket: str | None
+    tor_control_port: int | None
+    tor_torrc: str
+    tor_socks_port: int
+    tor_cookie_auth_file: str
+    tor_path: str = dirs.get_tor_paths()
+    tor_proc: subprocess.Process | None
+    connected_to_tor: bool = False
+    auth_string: str
+    graceful_close_onions: list = list()
+
+    def __init__(self):
+        self.tor_data_directory = tempfile.TemporaryDirectory(
+            dir=dirs.build_tmp_dir()
+        )
+        self.tor_data_directory_name = self.tor_data_directory.name
+        os.makedirs(os.path.join(self.tor_data_directory_name, 'auth'))
+
+    def kill_same_tor(self):
+        """
+        Kills tor process that looks like process to be created now
+        """
+        for proc in psutil.process_iter(["pid", "name", "username"]):
+            try:
+                cmdline = proc.cmdline()
+                if (
+                        cmdline[0] == self.tor_path
+                        and cmdline[1] == "-f"
+                        and cmdline[2] == self.tor_torrc
+                ):
+                    proc.terminate()
+                    proc.wait()
+                    break
+            except Exception as e:
+                assert e
+
+    def get_config(self, tor_data_directory_name: str) -> dict:
+        """
+        Build config dict for launching tor
+        :param tor_data_directory_name: Data directory for tor, can be generated
+                                        using code from core/dirs
+        :return:
+        """
+        self.tor_cookie_auth_file = os.path.join(tor_data_directory_name, "cookie")
+        try:
+            self.tor_socks_port = get_available_port(1000, 65535)
+        except Exception as e:
+            print(f"Cannot bind any port for socks proxy: {e}")
+        self.tor_torrc = os.path.join(tor_data_directory_name, "torrc")
+
+        self.kill_same_tor()
+
+        config = {
+            'DataDirectory': tor_data_directory_name,
+            'SocksPort': str(self.tor_socks_port),
+            'CookieAuthentication': '1',
+            'CookieAuthFile': self.tor_cookie_auth_file,
+            'ClientOnionAuthDir': os.path.join(tor_data_directory_name, 'auth'),
+            'AvoidDiskWrites': '1',
+            'Log': [
+                'NOTICE stdout'
+            ]
+        }
+
+        if platform.system() in ["Windows", "Darwin"] or \
+                len(tor_data_directory_name) > 90:
+            try:
+                self.tor_control_port = get_available_port(1000, 65535)
+                config = config | {"ControlPort": str(self.tor_control_port)}
+            except Exception as e:
+                print(f"Cannot bind any control port: {e}")
+            self.tor_control_socket = None
+        else:
+            self.tor_control_port = None
+            self.tor_control_socket = os.path.abspath(os.path.join(
+                tor_data_directory_name, "control_socket"
+            ))
+            config = config | {"ControlSocket": str(self.tor_control_socket)}
+
+        return config
+
+    async def connect(self, init_msg_handler=print):
+        """
+        Connect to tor network
+        :param init_msg_handler: Function that will print logs
+        :return:
+        """
+        self.tor_proc = await launch_tor_with_config(
+            config=self.get_config(self.tor_data_directory_name),
+            tor_cmd=self.tor_path,
+            take_ownership=True,
+            init_msg_handler=init_msg_handler
+        )
+
+        time.sleep(2)
+
+        if not self.tor_control_socket:
+            self.c = Controller.from_port(port=self.tor_control_port)
+            self.c.authenticate()
+        else:
+            self.c = Controller.from_socket_file(path=self.tor_control_socket)
+            self.c.authenticate()
+
+        self.connected_to_tor = True
+
+    def is_authenticated(self):
+        """
+        Check if controller authenticated
+        :return:
+        """
+        if self.c is not None:
+            return self.c.is_authenticated()
+        else:
+            return False
+
+    def cleanup(self):
+        """
+        Stop tor and clean up (hopefully) all footprints
+        :return:
+        """
+        if self.tor_proc:
+            try:
+                rendezvous_circuit_ids = []
+                for c in self.c.get_circuits():
+                    if (
+                            c.purpose == "HS_SERVICE_REND"
+                            and c.rend_query in self.graceful_close_onions
+                    ):
+                        rendezvous_circuit_ids.append(c.id)
+
+                symbols = list("\\|/-")
+                symbols_i = 0
+
+                while True:
+                    num_rend_circuits = 0
+                    for c in self.c.get_circuits():
+                        if c.id in rendezvous_circuit_ids:
+                            num_rend_circuits += 1
+
+                    if num_rend_circuits == 0:
+                        print(
+                            "\rTor rendezvous circuits have closed" + " " * 20
+                        )
+                        break
+
+                    if num_rend_circuits == 1:
+                        circuits = "circuit"
+                    else:
+                        circuits = "circuits"
+                    print(
+                        f"\rWaiting for {num_rend_circuits} Tor rendezvous {circuits} "
+                        f"to close {symbols[symbols_i]} ",
+                        end="",
+                    )
+                    symbols_i = (symbols_i + 1) % len(symbols)
+                    time.sleep(1)
+            except Exception as e:
+                print(e)
+
+            try:
+                self.tor_proc.terminate()
+                time.sleep(0.2)
+            except Exception as e:
+                assert e
+            try:
+                self.tor_proc.kill()
+                time.sleep(0.2)
+            except Exception as e:
+                assert e
+            self.tor_proc = None
+
+        self.connected_to_tor = False
+
+        try:
+            self.tor_data_directory.cleanup()
+        except Exception as e:
+            print(f'Cannot cleanup temporary directory: {e}')
+
+    def get_tor_socks_port(self):
+        return "127.0.0.1", self.tor_socks_port
```

## dragonion/utils/onion/tor_downloader.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-import os
-import io
-import tarfile
-import requests
-import re
-import sys
-from typing import Literal
-
-
-def get_latest_version() -> str:
-    """
-    Gets latest non-alfa version name from dist.torproject.org
-    :return:
-    """
-    r = requests.get('https://dist.torproject.org/torbrowser/').text
-
-    results = re.findall(r'<a href=".+/">(.+)/</a>', r)
-    for res in results:
-        if 'a' not in res:
-            return res
-
-
-def get_build() -> Literal[
-    'windows-x86_64',
-    'linux-x86_64',
-    'macos-x86_64',
-    'macos-aarch64'
-]:
-    """
-    Gets proper build name for your system
-    :return:
-    """
-    if sys.platform == 'win32':
-        return 'windows-x86_64'
-    elif sys.platform == 'linux':
-        return 'linux-x86_64'
-    elif sys.platform == 'darwin':
-        import platform
-        if platform.uname().machine == 'arm64':
-            return 'macos-aarch64'
-        else:
-            return 'macos-x86_64'
-    else:
-        raise 'System not supported'
-
-
-def get_tor_expert_bundles(version: str = get_latest_version(),
-                           platform: str = get_build()):
-    """
-    Returns a link for downloading tor expert bundle by version and platform
-    :param version: Tor expert bundle version that exists in dist.torproject.org
-    :param platform: Build type based on platform and arch, can be generated using
-                     get_build()
-    :return:
-    """
-    return f'https://dist.torproject.org/torbrowser/{version}/tor-expert-bundle-' \
-           f'{version}-{platform}.tar.gz'
-
-
-def download_tor(url: str = get_tor_expert_bundles(), dist: str = 'tor'):
-    """
-    Downloads tor from url and unpacks it to specified directory. Note, that
-    it doesn't unpack only tor executable to dist folder, but creates there
-    tor folder, where tor executable and libs are stored
-    :param url: Direct link for downloading
-    :param dist: Directory where to unpack archive (tor folder will appear there)
-    :return:
-    """
-    if not os.path.exists(dist):
-        os.makedirs(dist)
-
-    (tar := tarfile.open(fileobj=io.BytesIO(requests.get(url).content),
-                         mode='r:gz')).extractall(
-        members=[
-            tarinfo
-            for tarinfo
-            in tar.getmembers()
-            if tarinfo.name.startswith("tor/")
-        ], path=dist)
-
-
-if __name__ == '__main__':
-    download_tor()
+import os
+import io
+import tarfile
+import requests
+import re
+import sys
+from typing import Literal
+
+
+def get_latest_version() -> str:
+    """
+    Gets latest non-alfa version name from dist.torproject.org
+    :return:
+    """
+    r = requests.get('https://dist.torproject.org/torbrowser/').text
+
+    results = re.findall(r'<a href=".+/">(.+)/</a>', r)
+    for res in results:
+        if 'a' not in res:
+            return res
+
+
+def get_build() -> Literal[
+    'windows-x86_64',
+    'linux-x86_64',
+    'macos-x86_64',
+    'macos-aarch64'
+]:
+    """
+    Gets proper build name for your system
+    :return:
+    """
+    if sys.platform == 'win32':
+        return 'windows-x86_64'
+    elif sys.platform == 'linux':
+        return 'linux-x86_64'
+    elif sys.platform == 'darwin':
+        import platform
+        if platform.uname().machine == 'arm64':
+            return 'macos-aarch64'
+        else:
+            return 'macos-x86_64'
+    else:
+        raise 'System not supported'
+
+
+def get_tor_expert_bundles(version: str = get_latest_version(),
+                           platform: str = get_build()):
+    """
+    Returns a link for downloading tor expert bundle by version and platform
+    :param version: Tor expert bundle version that exists in dist.torproject.org
+    :param platform: Build type based on platform and arch, can be generated using
+                     get_build()
+    :return:
+    """
+    return f'https://dist.torproject.org/torbrowser/{version}/tor-expert-bundle-' \
+           f'{version}-{platform}.tar.gz'
+
+
+def download_tor(url: str = get_tor_expert_bundles(), dist: str = 'tor'):
+    """
+    Downloads tor from url and unpacks it to specified directory. Note, that
+    it doesn't unpack only tor executable to dist folder, but creates there
+    tor folder, where tor executable and libs are stored
+    :param url: Direct link for downloading
+    :param dist: Directory where to unpack archive (tor folder will appear there)
+    :return:
+    """
+    if not os.path.exists(dist):
+        os.makedirs(dist)
+
+    (tar := tarfile.open(fileobj=io.BytesIO(requests.get(url).content),
+                         mode='r:gz')).extractall(
+        members=[
+            tarinfo
+            for tarinfo
+            in tar.getmembers()
+            if tarinfo.name.startswith("tor/")
+        ], path=dist)
+
+
+if __name__ == '__main__':
+    download_tor()
```

## Comparing `dragonion-0.1.0rc0.dist-info/METADATA` & `dragonion-0.1.0rc3.dist-info/METADATA`

 * *Files 8% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dragonion
-Version: 0.1.0rc0
+Version: 0.1.0rc3
 Summary: 
 Author: BarsTiger
 Author-email: zxcbarstiger@gmail.com
 Requires-Python: >=3.10,<3.12
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
```

